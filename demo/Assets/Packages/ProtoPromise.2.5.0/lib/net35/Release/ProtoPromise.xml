<?xml version="1.0"?>
<doc>
    <assembly>
        <name>ProtoPromise</name>
    </assembly>
    <members>
        <member name="T:Proto.Promises.CancelationRegistration">
            <summary>
            Represents a callback delegate that has been registered with a <see cref="T:Proto.Promises.CancelationToken"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.#ctor(Proto.Promises.Internal.CancelationRef,Proto.Promises.Internal.CancelationCallbackNode,System.Int32,System.Int32)">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="P:Proto.Promises.CancelationRegistration.Token">
            <summary>
            Get the <see cref="T:Proto.Promises.CancelationToken"/> associated with this <see cref="T:Proto.Promises.CancelationRegistration"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.CancelationRegistration.IsRegistered">
            <summary>
            Get whether the callback is registered.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.GetIsRegisteredAndIsCancelationRequested(System.Boolean@,System.Boolean@)">
            <summary>
            Get whether the callback is registered and whether the associated <see cref="T:Proto.Promises.CancelationToken"/> is requesting cancelation as an atomic operation.
            </summary>
            <param name="isRegistered">true if this is registered, false otherwise</param>
            <param name="isTokenCancelationRequested">true if the associated <see cref="T:Proto.Promises.CancelationToken"/> is requesting cancelation, false otherwise</param>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.TryUnregister">
            <summary>
            Try to unregister the callback from the associated <see cref="T:Proto.Promises.CancelationToken"/>. Returns true if the callback was successfully unregistered, false otherwise.
            </summary>
            <returns>true if the callback was previously registered and the associated <see cref="T:Proto.Promises.CancelationToken"/> not yet canceled and the associated <see cref="T:Proto.Promises.CancelationSource"/> not yet disposed, false otherwise</returns>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.TryUnregister(System.Boolean@)">
            <summary>
            Try to unregister the callback from the associated <see cref="T:Proto.Promises.CancelationToken"/>. Returns true if the callback was successfully unregistered, false otherwise.
            <paramref name="isTokenCancelationRequested"/> will be true if the associated <see cref="T:Proto.Promises.CancelationToken"/> is requesting cancelation, false otherwise.
            </summary>
            <param name="isTokenCancelationRequested">true if the associated <see cref="T:Proto.Promises.CancelationToken"/> is requesting cancelation, false otherwise</param>
            <returns>true if the callback was previously registered and the associated <see cref="T:Proto.Promises.CancelationSource"/> not yet canceled or disposed, false otherwise</returns>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.Dispose">
            <summary>
            Try to unregister the callback from the associated <see cref="T:Proto.Promises.CancelationToken"/>.
            If the callback is currently executing, this method will wait until it completes,
            except in the degenerate case where the callback itself is unregistering itself.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.DisposeAsync">
            <summary>
            Try to unregister the callback from the associated <see cref="T:Proto.Promises.CancelationToken"/>.
            The returned <see cref="T:Proto.Promises.Promise"/> will be resolved once the associated callback
            is unregistered without having executed or once it's finished executing, except
            in the degenerate case where the callback itself is unregistering itself.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.Equals(Proto.Promises.CancelationRegistration)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.CancelationRegistration"/>.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.op_Equality(Proto.Promises.CancelationRegistration,Proto.Promises.CancelationRegistration)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.CancelationRegistration"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationRegistration.op_Inequality(Proto.Promises.CancelationRegistration,Proto.Promises.CancelationRegistration)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.CancelationRegistration"/> values are not equal.</summary>
        </member>
        <member name="T:Proto.Promises.CancelationSource">
            <summary>
            Cancelation source used to cancel operations.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.New">
            <summary>
            Create a new <see cref="T:Proto.Promises.CancelationSource"/>.
            <para/>Note: the new <see cref="T:Proto.Promises.CancelationSource"/> must be disposed when you are finished with it.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.New(Proto.Promises.CancelationToken)">
            <summary>
            Create a new <see cref="T:Proto.Promises.CancelationSource"/> that will be canceled either when you cancel it, or when the given token is canceled (with the same value), whichever is first.
            <para/>Note: the new <see cref="T:Proto.Promises.CancelationSource"/> still must be disposed when you are finished with it.
            </summary>
            <param name="token">The cancelation token to observe.</param>
            <returns>A new <see cref="T:Proto.Promises.CancelationSource"/> that is linked to the source token.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationSource.New(Proto.Promises.CancelationToken,Proto.Promises.CancelationToken)">
            <summary>
            Create a new <see cref="T:Proto.Promises.CancelationSource"/> that will be canceled either when you cancel it, or when any of the given tokens are canceled (with the same value), whichever is first.
            <para/>Note: the new <see cref="T:Proto.Promises.CancelationSource"/> still must be disposed when you are finished with it.
            </summary>
            <param name="token1">The first cancelation token to observe.</param>
            <param name="token2">The second cancelation token to observe.</param>
            <returns>A new <see cref="T:Proto.Promises.CancelationSource"/> that is linked to the source token.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationSource.New(Proto.Promises.CancelationToken[])">
            <summary>
            Create a new <see cref="T:Proto.Promises.CancelationSource"/> that will be canceled either when you cancel it, or when any of the given tokens are canceled (with the same value), whichever is first.
            <para/>Note: the new <see cref="T:Proto.Promises.CancelationSource"/> still must be disposed when you are finished with it.
            </summary>
            <param name="tokens">An array that contains the cancelation token instances to observe.</param>
            <returns>A new <see cref="T:Proto.Promises.CancelationSource"/> that is linked to the source token.</returns>
        </member>
        <member name="P:Proto.Promises.CancelationSource.Token">
            <summary>
            Get the <see cref="T:Proto.Promises.CancelationToken"/> associated with this <see cref="T:Proto.Promises.CancelationSource"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.CancelationSource.IsValid">
            <summary>
            Get whether or not this <see cref="T:Proto.Promises.CancelationSource"/> is valid.
            <para/>A <see cref="T:Proto.Promises.CancelationSource"/> is valid if it was created from <see cref="M:Proto.Promises.CancelationSource.New"/> and was not disposed.
            </summary>
        </member>
        <member name="P:Proto.Promises.CancelationSource.IsCancelationRequested">
            <summary>
            Gets whether cancelation has been requested for this source.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.TryCancel">
            <summary>
            Try to communicate a request for cancelation, and invoke all callbacks that are registered to the associated <see cref="P:Proto.Promises.CancelationSource.Token"/>. Returns true if successful, false otherwise.
            </summary>
            <returns>True if this is valid and was not already canceled, false otherwise.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationSource.Cancel">
            <summary>
            Communicate a request for cancelation, and invoke all callbacks that are registered to the associated <see cref="P:Proto.Promises.CancelationSource.Token"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.CancelationSource.TryDispose">
            <summary>
            Try to release all resources used by this <see cref="T:Proto.Promises.CancelationSource"/>. This instance will no longer be valid.
            </summary>
            <returns>True if this is valid and was not already disposed, false otherwise.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationSource.Dispose">
            <summary>
            Release all resources used by this <see cref="T:Proto.Promises.CancelationSource"/>. This instance will no longer be valid.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.CancelationSource.Equals(Proto.Promises.CancelationSource)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.CancelationSource"/>.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.op_Equality(Proto.Promises.CancelationSource,Proto.Promises.CancelationSource)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.CancelationSource"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationSource.op_Inequality(Proto.Promises.CancelationSource,Proto.Promises.CancelationSource)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.CancelationSource"/> values are not equal.</summary>
        </member>
        <member name="T:Proto.Promises.CancelationToken">
            <summary>
            Propagates notification that operations should be canceled.
            </summary>
        </member>
        <member name="P:Proto.Promises.CancelationToken.None">
            <summary>
            Returns an empty <see cref="T:Proto.Promises.CancelationToken"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.#ctor(Proto.Promises.Internal.CancelationRef,System.Int32)">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Canceled">
            <summary>
            Get a token that is already in the canceled state.
            </summary>
        </member>
        <member name="P:Proto.Promises.CancelationToken.CanBeCanceled">
            <summary>
            Gets whether this token is capable of being in the canceled state.
            </summary>
            <remarks>
            A <see cref="T:Proto.Promises.CancelationToken"/> is capable of being in the canceled state when the <see cref="T:Proto.Promises.CancelationSource"/> it is attached to has not been disposed,
            or if the token is already canceled and it has been retained and not yet released.
            </remarks>
        </member>
        <member name="P:Proto.Promises.CancelationToken.IsCancelationRequested">
            <summary>
            Gets whether cancelation has been requested for this token.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.ThrowIfCancelationRequested">
            <summary>
            If cancelation was requested on this token, throws a <see cref="T:Proto.Promises.CanceledException"/>.
            </summary>
            <exception cref="T:Proto.Promises.CanceledException"/>
        </member>
        <member name="M:Proto.Promises.CancelationToken.TryRegister(System.Action,Proto.Promises.CancelationRegistration@)">
            <summary>
            Try to register a delegate that will be invoked when this <see cref="T:Proto.Promises.CancelationToken"/> is canceled.
            If this is already canceled, the callback will be invoked immediately and this will return true.
            </summary>
            <param name="callback">The delegate to be executed when the <see cref="T:Proto.Promises.CancelationToken"/> is canceled.</param>
            <param name="cancelationRegistration">The <see cref="T:Proto.Promises.CancelationRegistration"/> instance that can be used to unregister the callback.</param>
            <returns>true if <paramref name="callback"/> was registered successfully, false otherwise.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationToken.TryRegister``1(``0,System.Action{``0},Proto.Promises.CancelationRegistration@)">
            <summary>
            Try to capture a value and register a delegate that will be invoked with the captured value when this <see cref="T:Proto.Promises.CancelationToken"/> is canceled.
            If this is already canceled, the callback will be invoked immediately and this will return true.
            </summary>
            <param name="captureValue">The value to pass into <paramref name="callback"/>.</param>
            <param name="callback">The delegate to be executed when the <see cref="T:Proto.Promises.CancelationToken"/> is canceled.</param>
            <param name="cancelationRegistration">The <see cref="T:Proto.Promises.CancelationRegistration"/> instance that can be used to unregister the callback.</param>
            <returns>true if <paramref name="callback"/> was registered successfully, false otherwise.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationToken.TryRegister``1(``0,Proto.Promises.CancelationRegistration@)">
            <summary>
            Try to register a cancelable that will be canceled when this <see cref="T:Proto.Promises.CancelationToken"/> is canceled.
            If this is already canceled, it will be canceled immediately and this will return true.
            </summary>
            <param name="cancelable">The cancelable to be canceled when the <see cref="T:Proto.Promises.CancelationToken"/> is canceled.</param>
            <param name="cancelationRegistration">The <see cref="T:Proto.Promises.CancelationRegistration"/> instance that can be used to unregister the callback.</param>
            <returns>true if <paramref name="cancelable"/> was registered successfully, false otherwise.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Register(System.Action)">
            <summary>
            Register a delegate that will be invoked when this <see cref="T:Proto.Promises.CancelationToken"/> is canceled.
            If this is already canceled, the callback will be invoked immediately.
            </summary>
            <param name="callback">The delegate to be executed when the <see cref="T:Proto.Promises.CancelationToken"/> is canceled.</param>
            <returns>The <see cref="T:Proto.Promises.CancelationRegistration"/> instance that can be used to unregister the callback.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Register``1(``0,System.Action{``0})">
            <summary>
            Capture a value and register a delegate that will be invoked with the captured value when this <see cref="T:Proto.Promises.CancelationToken"/> is canceled.
            If this is already canceled, the callback will be invoked immediately.
            </summary>
            <param name="captureValue">The value to pass into <paramref name="callback"/>.</param>
            <param name="callback">The delegate to be executed when the <see cref="T:Proto.Promises.CancelationToken"/> is canceled.</param>
            <returns>The <see cref="T:Proto.Promises.CancelationRegistration"/> instance that can be used to unregister the callback.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Register``1(``0)">
            <summary>
            Register a cancelable that will be canceled when this <see cref="T:Proto.Promises.CancelationToken"/> is canceled.
            If this is already canceled, it will be canceled immediately.
            </summary>
            <param name="cancelable">The cancelable to be canceled when the <see cref="T:Proto.Promises.CancelationToken"/> is canceled.</param>
            <returns>The <see cref="T:Proto.Promises.CancelationRegistration"/> instance that can be used to unregister the callback.</returns>
        </member>
        <member name="M:Proto.Promises.CancelationToken.TryRetain">
            <summary>
            Try to retain this instance. Returns true if successful, false otherwise.
            <para/>If successful, allows continued use of this instance, even after the associated <see cref="T:Proto.Promises.CancelationSource"/> has been disposed, until this is released.
            If successful, this should be paired with a call to <see cref="M:Proto.Promises.CancelationToken.Release"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Release">
            <summary>
            Release this instance. Allows resources to be released when the associated <see cref="T:Proto.Promises.CancelationSource"/> is disposed (if <see cref="M:Proto.Promises.CancelationToken.Release"/> has been called for all <see cref="M:Proto.Promises.CancelationToken.Retain"/> calls).
            <para/>This should always be paired with a call to <see cref="M:Proto.Promises.CancelationToken.Retain"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.CancelationToken.GetRetainer">
            <summary>
            Gets a retainer that facilitates retaining and releasing this instance. This is intended to be used with a using block `using (token.GetRetainer()) { ... }`.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Equals(Proto.Promises.CancelationToken)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.CancelationToken"/>.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.op_Equality(Proto.Promises.CancelationToken,Proto.Promises.CancelationToken)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.CancelationToken"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.op_Inequality(Proto.Promises.CancelationToken,Proto.Promises.CancelationToken)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.CancelationToken"/> values are not equal.</summary>
        </member>
        <member name="T:Proto.Promises.CancelationToken.Retainer">
            <summary>
            A helper type that facilitates retaining and releasing <see cref="T:Proto.Promises.CancelationToken"/>s with a using statement.
            This is intended to be used instead of <see cref="M:Proto.Promises.CancelationToken.TryRetain"/> and <see cref="M:Proto.Promises.CancelationToken.Release"/> to reduce boilerplate code.
            </summary>
        </member>
        <member name="M:Proto.Promises.CancelationToken.Retainer.Dispose">
            <summary>
            Releases the token if it was retained. This instance is no longer valid after it has been disposed, and should not continue to be used.
            </summary>
        </member>
        <member name="T:Proto.Promises.Extensions">
            <summary>
            Helpful extensions to convert promises to and from other asynchronous types.
            </summary>
        </member>
        <member name="T:Proto.Promises.Internal">
            <summary>
            Members of this type are meant for INTERNAL USE ONLY! Do not use in user code! Use the documented public APIs.
            </summary>
        </member>
        <member name="M:Proto.Promises.Internal.Enumerator`1.MoveNext">
            <summary>
            Doesn't actually move next, just returns if Current is valid.
            This allows the function to be branch-less. Useful for foreach loops.
            </summary>
        </member>
        <member name="P:Proto.Promises.Internal.Enumerator`1.Current">
            <summary>
            Actually moves next and returns current.
            </summary>
        </member>
        <member name="T:Proto.Promises.Internal.ValueLinkedStack`1">
            <summary>
            This structure is unsuitable for general purpose.
            </summary>
        </member>
        <member name="T:Proto.Promises.Internal.SpinLocker">
            <summary>
            Use instead of Monitor.Enter(object).
            Must not be readonly.
            </summary>
        </member>
        <member name="T:Proto.Promises.Internal.ValueLinkedStackSafe">
            <summary>
            This structure is unsuitable for general purpose.
            </summary>
        </member>
        <member name="T:Proto.Promises.Internal.ValueLinkedQueue`1">
            <summary>
            This structure is unsuitable for general purpose.
            </summary>
        </member>
        <member name="T:Proto.Promises.Internal.ValueList`1">
            <summary>
            This structure is unsuitable for general purpose.
            </summary>
        </member>
        <member name="T:Proto.Promises.AggregateException">
            <summary>Represents one or more errors that occur during application execution.</summary>
            <remarks>
            <see cref="T:Proto.Promises.AggregateException"/> is used to consolidate multiple failures into a single, throwable
            exception object.
            </remarks>
        </member>
        <member name="M:Proto.Promises.AggregateException.#ctor(System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:Proto.Promises.AggregateException"/> class with
            references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:Proto.Promises.AggregateException.#ctor(System.String,System.Collections.Generic.IEnumerable{System.Exception})">
            <summary>
            Initializes a new instance of the <see cref="T:Proto.Promises.AggregateException"/> class with a specified error
            message and references to the inner exceptions that are the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:Proto.Promises.AggregateException.#ctor(System.String,System.Collections.Generic.IList{System.Exception})">
            <summary>
            Allocates a new aggregate exception with the specified message and list of inner exceptions.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerExceptions">The exceptions that are the cause of the current exception.</param>
            <exception cref="T:System.ArgumentNullException">The <paramref name="innerExceptions"/> argument
            is null.</exception>
            <exception cref="T:System.ArgumentException">An element of <paramref name="innerExceptions"/> is
            null.</exception>
        </member>
        <member name="M:Proto.Promises.AggregateException.GetBaseException">
            <summary>
            Returns the <see cref="T:Proto.Promises.AggregateException"/> that is the root cause of this exception.
            </summary>
        </member>
        <member name="P:Proto.Promises.AggregateException.InnerExceptions">
            <summary>
            Gets a read-only collection of the <see cref="T:System.Exception"/> instances that caused the
            current exception.
            </summary>
        </member>
        <member name="M:Proto.Promises.AggregateException.Handle(System.Func{System.Exception,System.Boolean})">
            <summary>
            Invokes a handler on each <see cref="T:System.Exception"/> contained by this <see cref="T:Proto.Promises.AggregateException"/>.
            </summary>
            <param name="predicate">The predicate to execute for each exception. The predicate accepts as an
            argument the <see cref="T:System.Exception"/> to be processed and returns a Boolean to indicate
            whether the exception was handled.</param>
            <remarks>
            Each invocation of the <paramref name="predicate"/> returns true or false to indicate whether the
            <see cref="T:System.Exception"/> was handled. After all invocations, if any exceptions went
            unhandled, all unhandled exceptions will be put into a new <see cref="T:Proto.Promises.AggregateException"/>
            which will be thrown. Otherwise, the <see cref="M:Proto.Promises.AggregateException.Handle(System.Func{System.Exception,System.Boolean})"/> method simply returns. If any
            invocations of the <paramref name="predicate"/> throws an exception, it will halt the processing
            of any more exceptions and immediately propagate the thrown exception as-is.
            </remarks>
            <exception cref="T:Proto.Promises.AggregateException">An exception contained by this <see cref="T:Proto.Promises.AggregateException"/> was not handled.</exception>
            <exception cref="T:System.ArgumentNullException">The <paramref name="predicate"/> argument is
            null.</exception>
        </member>
        <member name="M:Proto.Promises.AggregateException.Flatten">
            <summary>
            Flattens an <see cref="T:Proto.Promises.AggregateException"/> instances into a single, new instance.
            </summary>
            <returns>A new, flattened <see cref="T:Proto.Promises.AggregateException"/>.</returns>
            <remarks>
            If any inner exceptions are themselves instances of
            <see cref="T:Proto.Promises.AggregateException"/>, this method will recursively flatten all of them. The
            inner exceptions returned in the new <see cref="T:Proto.Promises.AggregateException"/>
            will be the union of all of the the inner exceptions from exception tree rooted at the provided
            <see cref="T:Proto.Promises.AggregateException"/> instance.
            </remarks>
        </member>
        <member name="M:Proto.Promises.AggregateException.ToString">
            <summary>
            Creates and returns a string representation of the current <see cref="T:Proto.Promises.AggregateException"/>.
            </summary>
            <returns>A string representation of the current exception.</returns>
        </member>
        <member name="P:Proto.Promises.AggregateException.InnerExceptionCount">
            <summary>
            This helper property is used by the DebuggerDisplay.
            
            Note that we don't want to remove this property and change the debugger display to {InnerExceptions.Count} 
            because DebuggerDisplay should be a single property access or parameterless method call, so that the debugger 
            can use a fast path without using the expression evaluator.
            
            See http://msdn.microsoft.com/en-us/library/x810d419.aspx
            </summary>
        </member>
        <member name="T:Proto.Promises.SpinWait">
            <summary>
            Provides support for spin-based waiting.
            </summary>
            <remarks>
            <para>
            <see cref="T:Proto.Promises.SpinWait"/> encapsulates common spinning logic. On single-processor machines, yields are
            always used instead of busy waits, and on computers with Intel™ processors employing Hyper-Threading™
            technology, it helps to prevent hardware thread starvation. SpinWait encapsulates a good mixture of
            spinning and true yielding.
            </para>
            <para>
            <see cref="T:Proto.Promises.SpinWait"/> is a value type, which means that low-level code can utilize SpinWait without
            fear of unnecessary allocation overheads. SpinWait is not generally useful for ordinary applications.
            In most cases, you should use the synchronization classes provided by the .NET Framework, such as
            <see cref="T:System.Threading.Monitor"/>. For most purposes where spin waiting is required, however,
            the <see cref="T:Proto.Promises.SpinWait"/> type should be preferred over the <see
            cref="M:System.Threading.Thread.SpinWait(System.Int32)"/> method.
            </para>
            <para>
            While SpinWait is designed to be used in concurrent applications, it is not designed to be
            used from multiple threads concurrently.  SpinWait's members are not thread-safe.  If multiple
            threads must spin, each should use its own instance of SpinWait.
            </para>
            </remarks>
        </member>
        <member name="P:Proto.Promises.SpinWait.Count">
            <summary>
            Gets the number of times <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> has been called on this instance.
            </summary>
        </member>
        <member name="P:Proto.Promises.SpinWait.NextSpinWillYield">
            <summary>
            Gets whether the next call to <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.
            </summary>
            <value>Whether the next call to <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> will yield the processor, triggering a
            forced context switch.</value>
            <remarks>
            On a single-CPU machine, <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> always yields the processor. On machines with
            multiple CPUs, <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> may yield after an unspecified number of calls.
            </remarks>
        </member>
        <member name="M:Proto.Promises.SpinWait.SpinOnce">
            <summary>
            Performs a single spin.
            </summary>
            <remarks>
            This is typically called in a loop, and may change in behavior based on the number of times a
            <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> has been called thus far on this instance.
            </remarks>
        </member>
        <member name="M:Proto.Promises.SpinWait.Reset">
            <summary>
            Resets the spin counter.
            </summary>
            <remarks>
            This makes <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> and <see cref="P:Proto.Promises.SpinWait.NextSpinWillYield"/> behave as though no calls
            to <see cref="M:Proto.Promises.SpinWait.SpinOnce"/> had been issued on this instance. If a <see cref="T:Proto.Promises.SpinWait"/> instance
            is reused many times, it may be useful to reset it to avoid yielding too soon.
            </remarks>
        </member>
        <member name="M:Proto.Promises.SpinWait.SpinUntil(System.Func{System.Boolean})">
            <summary>
            Spins until the specified condition is satisfied.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <exception cref="T:Proto.Promises.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
        </member>
        <member name="M:Proto.Promises.SpinWait.SpinUntil(System.Func{System.Boolean},System.TimeSpan)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="timeout">
            A <see cref="T:System.TimeSpan"/> that represents the number of milliseconds to wait, 
            or a TimeSpan that represents -1 milliseconds to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:Proto.Promises.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="timeout"/> is a negative number
            other than -1 milliseconds, which represents an infinite time-out -or- timeout is greater than
            <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:Proto.Promises.SpinWait.SpinUntil(System.Func{System.Boolean},System.Int32)">
            <summary>
            Spins until the specified condition is satisfied or until the specified timeout is expired.
            </summary>
            <param name="condition">A delegate to be executed over and over until it returns true.</param>
            <param name="millisecondsTimeout">The number of milliseconds to wait, or <see
            cref="F:System.Threading.Timeout.Infinite"/> (-1) to wait indefinitely.</param>
            <returns>True if the condition is satisfied within the timeout; otherwise, false</returns>
            <exception cref="T:Proto.Promises.ArgumentNullException">The <paramref name="condition"/> argument is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="millisecondsTimeout"/> is a
            negative number other than -1, which represents an infinite time-out.</exception>
        </member>
        <member name="T:Proto.Promises.PlatformHelper">
            <summary>
            A helper class to get the number of processors, it updates the numbers of processors every sampling interval.
            </summary>
        </member>
        <member name="P:Proto.Promises.PlatformHelper.ProcessorCount">
            <summary>
            Gets the number of available processors
            </summary>
        </member>
        <member name="P:Proto.Promises.PlatformHelper.IsSingleProcessor">
            <summary>
            Gets whether the current machine has only a single processor.
            </summary>
        </member>
        <member name="T:Proto.Promises.TimeoutHelper">
            <summary>
            A helper class to capture a start time using Environment.TickCout as a time in milliseconds, also updates a given timeout bu subtracting the current time from
            the start time
            </summary>
        </member>
        <member name="M:Proto.Promises.TimeoutHelper.GetTime">
            <summary>
            Returns the Environment.TickCount as a start time in milliseconds as a uint, TickCount tools over from postive to negative every ~ 25 days
            then ~25 days to back to positive again, uint is sued to ignore the sign and double the range to 50 days
            </summary>
            <returns></returns>
        </member>
        <member name="M:Proto.Promises.TimeoutHelper.UpdateTimeOut(System.UInt32,System.Int32)">
            <summary>
            Helper function to measure and update the elapsed time
            </summary>
            <param name="startTime"> The first time (in milliseconds) observed when the wait started</param>
            <param name="originalWaitMillisecondsTimeout">The orginal wait timeoutout in milliseconds</param>
            <returns>The new wait time in milliseconds, -1 if the time expired</returns>
        </member>
        <member name="T:Proto.Promises.ICancelable">
            <summary>
            Cancelable interface
            </summary>
        </member>
        <member name="M:Proto.Promises.ICancelable.Cancel">
            <summary>
            Cancel this instance.
            </summary>
        </member>
        <member name="T:Proto.Promises.IRetainable">
            <summary>
            Retainable interface
            </summary>
        </member>
        <member name="M:Proto.Promises.IRetainable.Retain">
            <summary>
            Retain this instance.
            <para/>This should always be paired with a call to <see cref="M:Proto.Promises.IRetainable.Release"/>
            </summary>
        </member>
        <member name="M:Proto.Promises.IRetainable.Release">
            <summary>
            Release this instance.
            <para/>This should always be paired with a call to <see cref="M:Proto.Promises.IRetainable.Retain"/>
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise">
            <summary>
            A <see cref="T:Proto.Promises.Promise"/> represents the eventual result of an asynchronous operation.
            The primary ways of interacting with a <see cref="T:Proto.Promises.Promise"/> are via the `await` keyword in an async function,
            or through its then method, which registers callbacks to be invoked when the <see cref="T:Proto.Promises.Promise"/> is resolved,
            or the reason why the <see cref="T:Proto.Promises.Promise"/> cannot be resolved.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.GetAwaiter">
            <summary>Gets an awaiter for this <see cref="T:Proto.Promises.Promise"/>.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>The awaiter.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.AwaitNoThrow">
            <summary>Gets an awaiter for this <see cref="T:Proto.Promises.Promise"/> that suppresses throws and returns a <see cref="T:Proto.Promises.Promise.ResultContainer"/> instead.</summary>
            <returns>The awaiter.</returns>
            <remarks> Use as `var resultContainer = await promise.AwaitNoThrow();`</remarks>
        </member>
        <member name="M:Proto.Promises.Promise.AwaitWithProgress(System.Single,System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function.
            The progress reported will be lerped from <paramref name="minProgress"/> to <paramref name="maxProgress"/>. Both values must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>Use as `await promise.AwaitWithProgress(minProgress, maxProgress);`</remarks>
        </member>
        <member name="M:Proto.Promises.Promise.AwaitWithProgress(System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function.
            The progress reported will be lerped from its current progress to <paramref name="maxProgress"/>. <paramref name="maxProgress"/> must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>
            If the previously awaited promise did not complete successfully, minProgress will be set to the previous <paramref name="maxProgress"/> instead of current.
            <para/>Use as `await promise.AwaitWithProgress(maxProgress);`
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.AwaitWithProgressNoThrow(System.Single,System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function,
            and suppresses throws and returns a <see cref="T:Proto.Promises.Promise.ResultContainer"/> instead.
            The progress reported will be lerped from <paramref name="minProgress"/> to <paramref name="maxProgress"/>. Both values must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>Use as `var resultContainer = await promise.AwaitWithProgressNoThrow(minProgress, maxProgress);`</remarks>
        </member>
        <member name="M:Proto.Promises.Promise.AwaitWithProgressNoThrow(System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function,
            and suppresses throws and returns a <see cref="T:Proto.Promises.Promise.ResultContainer"/> instead.
            The progress reported will be lerped from its current progress to <paramref name="maxProgress"/>. <paramref name="maxProgress"/> must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>
            If the previously awaited promise did not complete successfully, minProgress will be set to the previous <paramref name="maxProgress"/> instead of current.
            <para/>Use as `var resultContainer = await promise.AwaitWithProgressNoThrow(maxProgress);`
            </remarks>
        </member>
        <member name="T:Proto.Promises.Promise.TraceLevel">
            <summary>
            At what granularity should stack traces be captured when a promise is created or rejected. Higher values are more costly, but give more information for debugging purposes.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.TraceLevel.None">
            <summary>
            Don't track any causality traces.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.TraceLevel.Rejections">
            <summary>
            Track causality only when Deferred.Reject is called.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.TraceLevel.All">
            <summary>
            Track causality when Deferred.Reject is called and every time a promise is created or a delegate is added to a promise (i.e. with .Then or .Progress).
            <para/>
            NOTE: This can be extremely expensive, so you should only enable this if you ran into an error and you are not sure where it came from.
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise.Config">
            <summary>
            Promise configuration. Configuration settings affect the global behaviour of promises.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.Config.ProgressPrecision">
            <summary>
            The distance between 1 and the largest value smaller than 1. Progress reports use full 32-bit float precision.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.Config.s_objectPoolingEnabled">
            <summary>
            Should objects be pooled or not. If this is enabled, objects can be reused to reduce GC pressure.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Config.DebugCausalityTracer">
            <summary>
            Set how causality is traced in DEBUG mode. Causality traces are readable from an UnhandledException's Stacktrace property.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Config.UncaughtRejectionHandler">
            <summary>
            Uncaught rejections get routed through this delegate.
            </summary>
            <remarks>
            This must be set to a non-null delegate, otherwise uncaught rejections will be thrown in the <see cref="P:Proto.Promises.Promise.Config.ForegroundContext"/> or <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.
            </remarks>
        </member>
        <member name="P:Proto.Promises.Promise.Config.ForegroundContext">
            <summary>
            The <see cref="T:System.Threading.SynchronizationContext"/> used to marshal work to the UI thread.
            </summary>
            <remarks>It is recommended to set this at application startup. It is also recommended to set <see cref="P:Proto.Promises.Promise.Manager.ThreadStaticSynchronizationContext"/> at the same time.</remarks>
            <example>
            <code>
            Promise.Config.ForegroundContext = SynchronizationContext.Current;
            </code>
            </example>
        </member>
        <member name="P:Proto.Promises.Promise.Config.BackgroundContext">
            <summary>
            The <see cref="T:System.Threading.SynchronizationContext"/> used to marshal work to a background thread. If this is null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> is used.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Config.AsyncFlowExecutionContextEnabled">
            <summary>
            When enabled, <see cref="!:AsyncLocal&lt;T&gt;"/> objects are supported in async <see cref="T:Proto.Promises.Promise"/> and async <see cref="T:Proto.Promises.Promise`1"/> methods.
            </summary>
            <remarks>
            This is disabled by default, and cannot be disabled after enabled.
            </remarks>
        </member>
        <member name="T:Proto.Promises.Promise.DeferredBase">
            <summary>
            Deferred base. An instance of this can be used to report progress and reject or cancel the attached <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/>.
            <para/>You must use <see cref="T:Proto.Promises.Promise.Deferred"/> or <see cref="T:Proto.Promises.Promise`1.Deferred"/> to resolve the attached <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.DeferredBase.Promise">
            <summary>
            The attached <see cref="T:Proto.Promises.Promise"/> that this controls.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.DeferredBase.IsValid">
            <summary>
            Get whether or not this instance and the attached <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/> are valid.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.DeferredBase.IsValidAndPending">
            <summary>
            Get whether or not this instance is valid and the attached <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/> is still pending.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.#ctor(Proto.Promises.Internal.IDeferredPromise,System.Int16,System.Int32)">
            <summary>
            Internal use for implicit cast operator.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.ToDeferred">
            <summary>
            Cast this to <see cref="T:Proto.Promises.Promise.Deferred"/>. Throws an <see cref="T:System.InvalidCastException"/> if it cannot be casted.
            </summary>
            <exception cref="T:System.InvalidCastException"/>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.AsDeferred">
            <summary>
            Cast this to <see cref="T:Proto.Promises.Promise.Deferred"/>. Returns an invalid <see cref="T:Proto.Promises.Promise.Deferred"/> if it cannot be casted.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.ToDeferred``1">
            <summary>
            Cast this to <see cref="T:Proto.Promises.Promise`1.Deferred"/>. Throws an <see cref="T:System.InvalidCastException"/> if it cannot be casted.
            </summary>
            <exception cref="T:System.InvalidCastException"/>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.AsDeferred``1">
            <summary>
            Cast this to <see cref="T:Proto.Promises.Promise`1.Deferred"/>. Returns an invalid <see cref="T:Proto.Promises.Promise`1.Deferred"/> if it cannot be casted.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.Reject``1(``0)">
            <summary>
            Reject the linked <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/> with <paramref name="reason"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.TryReject``1(``0)">
            <summary>
            Try to reject the linked <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/> with <paramref name="reason"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.Cancel">
            <summary>
            Cancel the linked <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.TryCancel">
            <summary>
            Try to cancel the linked <see cref="P:Proto.Promises.Promise.DeferredBase.Promise"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.ReportProgress(System.Single)">
            <summary>
            Report progress between 0 and 1.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.TryReportProgress(System.Single)">
            <summary>
            Try to report progress between 0 and 1.
            <para/> Returns true if successful, false otherwise.
            </summary>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.Equals(Proto.Promises.Promise.DeferredBase)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.Promise.DeferredBase"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.op_Equality(Proto.Promises.Promise.DeferredBase,Proto.Promises.Promise.DeferredBase)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise.DeferredBase"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.DeferredBase.op_Inequality(Proto.Promises.Promise.DeferredBase,Proto.Promises.Promise.DeferredBase)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise.DeferredBase"/> values are not equal.</summary>
        </member>
        <member name="T:Proto.Promises.Promise.Deferred">
            <summary>
            An instance of this is used to report progress and resolve, reject, or cancel the attached <see cref="P:Proto.Promises.Promise.Deferred.Promise"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Deferred.Promise">
            <summary>
            The attached <see cref="T:Proto.Promises.Promise"/> that this controls.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Deferred.IsValid">
            <summary>
            Get whether or not this instance and the attached <see cref="P:Proto.Promises.Promise.Deferred.Promise"/> are valid.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Deferred.IsValidAndPending">
            <summary>
            Get whether or not this instance is valid and the attached <see cref="P:Proto.Promises.Promise.Deferred.Promise"/> is still pending.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.#ctor(Proto.Promises.Internal.PromiseRefBase.DeferredPromise{Proto.Promises.Internal.VoidResult},System.Int16,System.Int32)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.New">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise.Deferred"/> instance that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.New(Proto.Promises.CancelationToken)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise.Deferred"/> instance that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If the <paramref name="cancelationToken"/> is canceled while the <see cref="T:Proto.Promises.Promise.Deferred"/> is pending, it and the <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.Resolve">
            <summary>
            Resolve the linked <see cref="P:Proto.Promises.Promise.Deferred.Promise"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.TryResolve">
            <summary>
            Try to resolve the linked <see cref="P:Proto.Promises.Promise.Deferred.Promise"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.Reject``1(``0)">
            <summary>
            Reject the linked <see cref="P:Proto.Promises.Promise.Deferred.Promise"/> with <paramref name="reason"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.TryReject``1(``0)">
            <summary>
            Try to reject the linked <see cref="P:Proto.Promises.Promise.Deferred.Promise"/> with <paramref name="reason"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.Cancel">
            <summary>
            Cancel the linked <see cref="P:Proto.Promises.Promise.Deferred.Promise"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.TryCancel">
            <summary>
            Try to cancel the linked <see cref="P:Proto.Promises.Promise.Deferred.Promise"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.ReportProgress(System.Single)">
            <summary>
            Report progress between 0 and 1.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.TryReportProgress(System.Single)">
            <summary>
            Try to report progress between 0 and 1.
            <para/> Returns true if successful, false otherwise.
            </summary>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.op_Implicit(Proto.Promises.Promise.Deferred)~Proto.Promises.Promise.DeferredBase">
            <summary>
            Cast to <see cref="T:Proto.Promises.Promise.DeferredBase"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.op_Explicit(Proto.Promises.Promise.DeferredBase)~Proto.Promises.Promise.Deferred">
            <summary>
            Cast <see cref="T:Proto.Promises.Promise.DeferredBase"/> to <see cref="T:Proto.Promises.Promise.Deferred"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.Equals(Proto.Promises.Promise.Deferred)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.Promise.Deferred"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.op_Equality(Proto.Promises.Promise.Deferred,Proto.Promises.Promise.Deferred)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise.Deferred"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.Deferred.op_Inequality(Proto.Promises.Promise.Deferred,Proto.Promises.Promise.Deferred)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise.Deferred"/> values are not equal.</summary>
        </member>
        <member name="T:Proto.Promises.Promise.State">
            <summary>
            The state of the promise.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.State.Pending">
            <summary>
            The promise has not yet completed. (The operation is in progress.)
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.State.Resolved">
            <summary>
            The promise completed successfully. (The operation ran to completion with no errors.)
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.State.Rejected">
            <summary>
            The promise failed to complete due to a reason.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.State.Canceled">
            <summary>
            The promise was canceled before the operation was able to complete.
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise.ContinueAction">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise.ContinueWith(Proto.Promises.Promise.ContinueAction,Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="T:Proto.Promises.Promise.ContinueAction`1">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise.ContinueWith``1(``0,Proto.Promises.Promise.ContinueAction{``0},Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="capturedValue">The value that was passed to <see cref="M:Proto.Promises.Promise.ContinueWith``1(``0,Proto.Promises.Promise.ContinueAction{``0},Proto.Promises.CancelationToken)"/>.</param>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="T:Proto.Promises.Promise.ContinueFunc`1">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise.ContinueWith``1(Proto.Promises.Promise.ContinueFunc{``0},Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="T:Proto.Promises.Promise.ContinueFunc`2">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise.ContinueWith``2(``0,Proto.Promises.Promise.ContinueFunc{``0,``1},Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="capturedValue">The value that was passed to <see cref="M:Proto.Promises.Promise.ContinueWith``2(``0,Proto.Promises.Promise.ContinueFunc{``0,``1},Proto.Promises.CancelationToken)"/>.</param>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="F:Proto.Promises.Promise._ref">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise._id">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Depth">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.#ctor(Proto.Promises.Internal.PromiseRefBase,System.Int16,System.UInt16)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise.Manager">
            <summary>
            Promise manager. This can be used to clear pooled objects (if enabled).
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Manager.ClearObjectPool">
            <summary>
            Clears all currently pooled objects. Does not affect pending or preserved promises.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Manager.ThreadStaticSynchronizationContext">
            <summary>
            The <see cref="T:System.Threading.SynchronizationContext"/> for the current thread, used internally to execute continuations synchronously if the supplied context matches this.
            </summary>
            <remarks>It is recommended to set this at application startup, at the same as you set <see cref="P:Proto.Promises.Promise.Config.ForegroundContext"/>.</remarks>
        </member>
        <member name="P:Proto.Promises.Promise.IsValid">
            <summary>
            Gets whether this instance is valid to be awaited.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Preserve">
            <summary>
            Mark this as awaited and get a new <see cref="T:Proto.Promises.Promise"/> that inherits the state of this and can be awaited multiple times until <see cref="M:Proto.Promises.Promise.Forget"/> is called on it.
            <para/><see cref="M:Proto.Promises.Promise.Forget"/> must be called when you are finished with it.
            <para/>NOTE: You should not return a preserved <see cref="T:Proto.Promises.Promise"/> from a public API. Use <see cref="M:Proto.Promises.Promise.Duplicate"/> to get a <see cref="T:Proto.Promises.Promise"/> that is publicly safe.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Forget">
            <summary>
            Mark this as awaited and prevent any further awaits or callbacks on this.
            <para/>NOTE: It is imperative to terminate your promise chains with Forget so that any uncaught rejections will be reported and objects repooled (if pooling is enabled).
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Wait">
            <summary>
            Mark this as awaited and wait for the operation to complete.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!</remarks>
        </member>
        <member name="M:Proto.Promises.Promise.WaitNoThrow">
            <summary>
            Mark this as awaited and wait for the operation to complete, without throwing. Returns a <see cref="T:Proto.Promises.Promise.ResultContainer"/> that wraps the completion state and reason.
            </summary>
            <remarks>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!</remarks>
        </member>
        <member name="M:Proto.Promises.Promise.Wait(System.TimeSpan)">
            <summary>
            Mark this as awaited and wait for the operation to complete with a specified timeout.
            <para/>This will return <see langword="true"/> if the operation completed successfully before the timeout expired, <see langword="false"/> otherwise.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>
            If a <see cref="T:System.TimeSpan"/> representing -1 millisecond is specified for the timeout parameter, this method blocks indefinitely until the operation is complete.
            <para/>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.TryWait(System.TimeSpan)">
            <summary>
            Mark this as awaited and wait for the operation to complete with a specified timeout.
            <para/>This will return <see langword="true"/> if the operation completed successfully before the timeout expired, <see langword="false"/> otherwise.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>
            If a <see cref="T:System.TimeSpan"/> representing -1 millisecond is specified for the timeout parameter, this method blocks indefinitely until the operation is complete.
            <para/>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.TryWaitNoThrow(System.TimeSpan,Proto.Promises.Promise.ResultContainer@)">
            <summary>
            Mark this as awaited and wait for the operation to complete with a specified timeout, without throwing. <paramref name="resultContainer"/> wraps the completion state and reason.
            <para/>This will return <see langword="true"/> if the operation completed successfully before the timeout expired, <see langword="false"/> otherwise.
            </summary>
            <remarks>
            If a <see cref="T:System.TimeSpan"/> representing -1 millisecond is specified for the timeout parameter, this method blocks indefinitely until the operation is complete.
            <para/>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.Duplicate">
            <summary>
            Mark this as awaited and get a new <see cref="T:Proto.Promises.Promise"/> that inherits the state of this and can be awaited once.
            <para/>Preserved promises are unsafe to return from public APIs. Use <see cref="M:Proto.Promises.Promise.Duplicate"/> to get a <see cref="T:Proto.Promises.Promise"/> that is publicly safe.
            <para/><see cref="M:Proto.Promises.Promise.Duplicate"/> is safe to call even if you are unsure if this is preserved.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.WaitAsync(Proto.Promises.SynchronizationOption,System.Boolean,Proto.Promises.CancelationToken)">
            <summary>
            Mark this as awaited and schedule the next continuation to execute on the context of the provided option.
            Returns a new <see cref="T:Proto.Promises.Promise"/> that inherits the state of this, or will be canceled if/when the <paramref name="cancelationToken"/> is canceled before this is complete.
            </summary>
            <param name="continuationOption">Indicates on which context the next continuation will be executed.</param>
            <param name="forceAsync">If true, forces the next continuation to be invoked asynchronously. If <paramref name="continuationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled before this is complete, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled, and the cancelation will propagate on the context of the provided <paramref name="continuationOption"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.WaitAsync(System.Threading.SynchronizationContext,System.Boolean,Proto.Promises.CancelationToken)">
            <summary>
            Mark this as awaited and schedule the next continuation to execute on <paramref name="continuationContext"/>.
            Returns a new <see cref="T:Proto.Promises.Promise"/> that inherits the state of this, or will be canceled if/when the <paramref name="cancelationToken"/> is canceled before this is complete.
            </summary>
            <param name="continuationContext">The context on which context the next continuation will be executed. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the next continuation to be invoked asynchronously.</param>
            <param name="cancelationToken">If canceled before this is complete, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and the cancelation will propagate on the provided <paramref name="continuationContext"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.WaitAsync(Proto.Promises.CancelationToken)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/> that inherits the state of this, or will be canceled if/when the <paramref name="cancelationToken"/> is canceled before the continuation is invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Progress``1(``0,Proto.Promises.SynchronizationOption,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            
            <para/>If/when this is resolved, <paramref name="progressListener"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
            <param name="progressListener">Will be reported with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeOption">Indicates on which context <paramref name="progressListener"/> will be reported.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously. If <paramref name="invokeOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Progress``1(``0,System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            
            <para/>If/when this is resolved, <paramref name="progressListener"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
            <param name="progressListener">Will be reported with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeContext">The context on which <paramref name="progressListener"/> will be reported. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Progress(System.Action{System.Single},Proto.Promises.SynchronizationOption,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
            <param name="onProgress">Will be invoked with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeOption">Indicates on which context <paramref name="onProgress"/> will be invoked.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously. If <paramref name="invokeOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Progress(System.Action{System.Single},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
            <param name="onProgress">Will be invoked with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeContext">The context on which <paramref name="onProgress"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Finally(System.Action)">
            <summary>
            Add a finally callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onFinally"/> will be invoked.
            <para/>If <paramref name="onFinally"/> throws an exception, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that exception,
            otherwise it will be resolved, rejected, or canceled with the same value or reason as this.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.CatchCancelation(System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.CatchCancelation(System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then(System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then(System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch(System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch``1(System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch(System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch``1(System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then(System.Action,System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Action,System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{``0},System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{``0},System.Func{``1,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then(System.Func{Proto.Promises.Promise},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise},System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise{``0}},System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{Proto.Promises.Promise{``0}},System.Func{``1,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then(System.Action,System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Action,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{``0},System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{``0},System.Func{``1,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then(System.Func{Proto.Promises.Promise},System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise},System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise{``0}},System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{Proto.Promises.Promise{``0}},System.Func{``1,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith(Proto.Promises.Promise.ContinueAction,Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith``1(Proto.Promises.Promise.ContinueFunc{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith(Proto.Promises.Promise.ContinueFunc{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith``1(Proto.Promises.Promise.ContinueFunc{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Progress``1(``0,System.Action{``0,System.Single},Proto.Promises.SynchronizationOption,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Capture a value and add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/><paramref name="onProgress"/> will be invoked  that is normalized between 0 and 1 on the context of the provided option.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with <paramref name="progressCaptureValue"/> and 1.0, then the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, <paramref name="onProgress"/> will stop being invoked.
            </summary>
            <param name="progressCaptureValue">The value that will be passed to <paramref name="onProgress"/>.</param>
            <param name="onProgress">Will be invoked with with <paramref name="progressCaptureValue"/> and progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeOption">Indicates on which context <paramref name="onProgress"/> will be invoked.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Progress``1(``0,System.Action{``0,System.Single},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Capture a value and add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with <paramref name="progressCaptureValue"/> and 1.0, then the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
            <param name="progressCaptureValue">The value that will be passed to <paramref name="onProgress"/>.</param>
            <param name="onProgress">Will be invoked with with <paramref name="progressCaptureValue"/> and progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeContext">The context on which <paramref name="onProgress"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Finally``1(``0,System.Action{``0})">
            <summary>
            Capture a value and add a finally callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onFinally"/> will be invoked with <paramref name="finallyCaptureValue"/>.
            <para/>If <paramref name="onFinally"/> throws an exception, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that exception,
            otherwise it will be resolved, rejected, or canceled with the same value or reason as this.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.CatchCancelation``1(``0,System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Capture a value and add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.CatchCancelation``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Capture a value and add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch``1(``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch``2(``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Catch``2(``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(``0,System.Action{``0},System.Action,Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Action,``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Action{``0},``1,System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Action{``0},System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Action,``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Action{``0},``1,System.Action{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,``1},System.Func{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{``1},``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,``2},``1,System.Func{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,``1},System.Func{``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(System.Func{``1},``0,System.Func{``0,``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``4(``0,System.Func{``0,``2},``1,System.Func{``1,``3,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(``0,System.Func{``0,Proto.Promises.Promise},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise},``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise},System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{Proto.Promises.Promise},``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Func{``1,``2,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``4(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``3,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(``0,System.Action{``0},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Action,``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Action{``0},``1,System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Action{``0},System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Action,``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Action{``0},``1,System.Func{``1,``2,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,``1},System.Func{Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{``1},``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,``2},``1,System.Func{``1,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,``1},System.Func{``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(System.Func{``1},``0,System.Func{``0,``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``4(``0,System.Func{``0,``2},``1,System.Func{``1,``3,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(``0,System.Func{``0,Proto.Promises.Promise},System.Action,Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``1(System.Func{Proto.Promises.Promise},``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise},System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{Proto.Promises.Promise},``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Action{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``2(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``3(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Then``4(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``3,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith``1(``0,Proto.Promises.Promise.ContinueAction{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith``2(``0,Proto.Promises.Promise.ContinueFunc{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith``1(``0,Proto.Promises.Promise.ContinueFunc{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ContinueWith``2(``0,Proto.Promises.Promise.ContinueFunc{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Equals(Proto.Promises.Promise)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.Promise"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.op_Equality(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.op_Inequality(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise"/> values are not equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise.ToString">
            <summary>
            Gets the string representation of this instance.
            </summary>
            <returns>The string representation of this instance.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelFor(System.Int32,System.Int32,System.Func{System.Int32,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for loop in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <param name="fromIndex">The start index, inclusive.</param>
            <param name="toIndex">The end index, exclusive.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelFor(System.Int32,System.Int32,System.Func{System.Int32,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for loop in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <param name="fromIndex">The start index, inclusive.</param>
            <param name="toIndex">The end index, exclusive.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelFor``1(System.Int32,System.Int32,``0,System.Func{System.Int32,``0,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for loop in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <param name="fromIndex">The start index, inclusive.</param>
            <param name="toIndex">The end index, exclusive.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelFor``1(System.Int32,System.Int32,``0,System.Func{System.Int32,``0,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for loop in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <param name="fromIndex">The start index, inclusive.</param>
            <param name="toIndex">The end index, exclusive.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelForEach``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelForEach``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel.</summary>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelForEach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <typeparam name="TCapture">The type of the captured value.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.ParallelForEach``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel.</summary>
            <typeparam name="TSource">The type of the data in the source.</typeparam>
            <typeparam name="TCapture">The type of the captured value.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise.Sequence(System.Func{Proto.Promises.Promise}[])">
            <summary>
            Runs <paramref name="promiseFuncs"/> in sequence, returning a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Sequence(Proto.Promises.CancelationToken,System.Func{Proto.Promises.Promise}[])">
            <summary>
            Runs <paramref name="promiseFuncs"/> in sequence, returning a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled before all of the <paramref name="promiseFuncs"/> have been invoked,
            the <paramref name="promiseFuncs"/> will stop being invoked, and the returned <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Sequence(System.Collections.Generic.IEnumerable{System.Func{Proto.Promises.Promise}})">
            <summary>
            Runs <paramref name="promiseFuncs"/> in sequence, returning a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Sequence(Proto.Promises.CancelationToken,System.Collections.Generic.IEnumerable{System.Func{Proto.Promises.Promise}})">
            <summary>
            Runs <paramref name="promiseFuncs"/> in sequence, returning a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled before all of the <paramref name="promiseFuncs"/> have been invoked,
            the <paramref name="promiseFuncs"/> will stop being invoked, and the returned <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Sequence``1(``0)">
            <summary>
            Runs <paramref name="promiseFuncs"/> in sequence, returning a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Sequence``1(Proto.Promises.CancelationToken,``0)">
            <summary>
            Runs <paramref name="promiseFuncs"/> in sequence, returning a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled before all of the <paramref name="promiseFuncs"/> have been invoked,
            the <paramref name="promiseFuncs"/> will stop being invoked, and the returned <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.SwitchToForeground(System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/> that will resolve on the foreground context.
            </summary>
            <param name="forceAsync">If true, forces the context switch to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.SwitchToBackground(System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/> that will resolve on the background context.
            </summary>
            <param name="forceAsync">If true, forces the context switch to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.SwitchToContext(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/> that will resolve on the provided <paramref name="synchronizationContext"/>
            </summary>
            <param name="synchronizationContext">The context to switch to. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the context switch to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.SwitchToForegroundAwait(System.Boolean)">
            <summary>
            Switch to the foreground context in an async method.
            </summary>
            <param name="forceAsync">If true, forces the context switch to happen asynchronously.</param>
            <remarks>
            This method is equivalent to <see cref="M:Proto.Promises.Promise.SwitchToForeground(System.Boolean)"/>, but is more efficient when used directly with the <see langword="await"/> keyword.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.SwitchToBackgroundAwait(System.Boolean)">
            <summary>
            Switch to the background context in an async method.
            </summary>
            <param name="forceAsync">If true, forces the context switch to happen asynchronously.</param>
            <remarks>
            This method is equivalent to <see cref="M:Proto.Promises.Promise.SwitchToBackground(System.Boolean)"/>, butbut is more efficient when used directly with the <see langword="await"/> keyword.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.SwitchToContextAwait(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Switch to the provided context in an async method.
            </summary>
            <param name="synchronizationContext">The context to switch to. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the context switch to happen asynchronously.</param>
            <remarks>
            This method is equivalent to <see cref="M:Proto.Promises.Promise.SwitchToContext(System.Threading.SynchronizationContext,System.Boolean)"/>, but is more efficient when used directly with the <see langword="await"/> keyword.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise.New(System.Action{Proto.Promises.Promise.Deferred},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/>. <paramref name="resolver"/> is invoked with a <see cref="T:Proto.Promises.Promise.Deferred"/> that controls the state of the new <see cref="T:Proto.Promises.Promise"/>.
            You may provide a <paramref name="synchronizationOption"/> to control the context on which the <paramref name="resolver"/> is invoked.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise.Deferred"/>.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="resolver"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.New(System.Action{Proto.Promises.Promise.Deferred},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/>. <paramref name="resolver"/> is invoked with a <see cref="T:Proto.Promises.Promise.Deferred"/> that controls the state of the new <see cref="T:Proto.Promises.Promise"/> on the provided <paramref name="synchronizationContext"/>.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise.Deferred"/>.</param>
            <param name="synchronizationContext">The context on which the <paramref name="resolver"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.New``1(``0,System.Action{``0,Proto.Promises.Promise.Deferred},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/>. <paramref name="resolver"/> is invoked with <paramref name="captureValue"/> and a <see cref="T:Proto.Promises.Promise.Deferred"/> that controls the state of the <see cref="T:Proto.Promises.Promise"/>.
            You may provide a <paramref name="synchronizationOption"/> to control the context on which the <paramref name="resolver"/> is invoked.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="resolver"/>.</param>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise.Deferred"/>.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="resolver"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.New``1(``0,System.Action{``0,Proto.Promises.Promise.Deferred},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise"/>. <paramref name="resolver"/> is invoked with <paramref name="captureValue"/> and a <see cref="T:Proto.Promises.Promise.Deferred"/> that controls the state of the <see cref="T:Proto.Promises.Promise"/> on the provided <paramref name="synchronizationContext"/>.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="resolver"/>.</param>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise.Deferred"/>.</param>
            <param name="synchronizationContext">The context on which the <paramref name="resolver"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run(System.Action,Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="action"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise"/> that will be resolved when the <paramref name="action"/> returns successfully.
            <para/>If the <paramref name="action"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="action">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="action"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(``0,System.Action{``0},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="action"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise"/> that will be resolved when the <paramref name="action"/> returns successfully.
            <para/>If the <paramref name="action"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="action"/>.</param>
            <param name="action">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="action"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run(System.Action,System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="action"/>  on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise"/> that will be resolved when the <paramref name="action"/> returns successfully.
            <para/>If the <paramref name="action"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="action">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="action"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(``0,System.Action{``0},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="action"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise"/> that will be resolved when the <paramref name="action"/> returns successfully.
            <para/>If the <paramref name="action"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="action"/>.</param>
            <param name="action">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="action"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(System.Func{``0},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will be resolved with the value returned by the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="function"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``2(``0,System.Func{``0,``1},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will be resolved with the value returned by the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="function"/>.</param>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="function"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(System.Func{``0},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="function"/>  on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will be resolved with the value returned by the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="function"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``2(``0,System.Func{``0,``1},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will be resolved with the value returned by the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="function"/>.</param>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="function"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run(System.Func{Proto.Promises.Promise},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="function"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="function"/>.</param>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="function"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run(System.Func{Proto.Promises.Promise},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="function"/>  on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="function"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(``0,System.Func{``0,Proto.Promises.Promise},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="function"/>.</param>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="function"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(System.Func{Proto.Promises.Promise{``0}},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise`1"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="function"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationOption"/> context. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise`1"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="function"/>.</param>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="function"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``1(System.Func{Proto.Promises.Promise{``0}},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="function"/>  on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise`1"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="function"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Run``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Run the <paramref name="function"/> with <paramref name="captureValue"/> on the provided <paramref name="synchronizationContext"/>. Returns a new <see cref="T:Proto.Promises.Promise`1"/> that will adopt the state of the <see cref="T:Proto.Promises.Promise`1"/> returned from the <paramref name="function"/>.
            <para/>If the <paramref name="function"/> throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>, or rejected with that <see cref="T:System.Exception"/>.
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="function"/>.</param>
            <param name="function">The delegate that will be invoked.</param>
            <param name="synchronizationContext">The context on which the <paramref name="function"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the invoke to happen asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise.Resolved">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that is already resolved.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Resolved``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that is already resolved with <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Rejected``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that is already rejected with <paramref name="reason"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Canceled">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that is already canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Canceled``1">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that is already canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.NewDeferred">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise.Deferred"/> instance that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.NewDeferred(Proto.Promises.CancelationToken)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise.Deferred"/> instance that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If the <paramref name="cancelationToken"/> is canceled while the <see cref="T:Proto.Promises.Promise.Deferred"/> is pending, it and the <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.NewDeferred``1">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1.Deferred"/> object that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.NewDeferred``1(Proto.Promises.CancelationToken)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1.Deferred"/> object that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise`1"/>.
            <para/>If the <paramref name="cancelationToken"/> is canceled while the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is pending, it and the <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.Rethrow">
            <summary>
            Get a <see cref="T:Proto.Promises.RethrowException"/> that can be thrown inside an onRejected callback to rethrow the caught rejection, preserving the stack trace.
            This should be used as "throw Promise.Rethrow;"
            This is similar to "throw;" in a synchronous catch clause.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.CancelException">
            <summary>
            Get a <see cref="T:Proto.Promises.CanceledException"/> that can be thrown to cancel the promise from an onResolved or onRejected callback, or in an async Promise function.
            This should be used as "throw Promise.CancelException();"
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RejectException``1(``0)">
            <summary>
            Get a <see cref="T:Proto.Promises.RejectException"/> that can be thrown to reject the promise from an onResolved or onRejected callback, or in an async Promise function.
            This should be used as "throw Promise.RejectException(value);"
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.All(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.All(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.All(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when all promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.All(Proto.Promises.Promise[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when all <paramref name="promises"/> have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.All(System.Collections.Generic.IEnumerable{Proto.Promises.Promise})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when all <paramref name="promises"/> have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.All``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when all <paramref name="promises"/> have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``1(Proto.Promises.Promise{``0},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve with the value of <paramref name="promise1"/> when both promises have resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``2(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``2(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``3(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`3"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``3(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`3"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``4(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`4"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``4(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`4"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``5(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise{``4})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`5"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``5(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise{``4},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`5"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``6(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise{``4},Proto.Promises.Promise{``5})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`6"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``6(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise{``4},Proto.Promises.Promise{``5},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`6"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``7(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise{``4},Proto.Promises.Promise{``5},Proto.Promises.Promise{``6})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`7"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Merge``7(Proto.Promises.Promise{``0},Proto.Promises.Promise{``1},Proto.Promises.Promise{``2},Proto.Promises.Promise{``3},Proto.Promises.Promise{``4},Proto.Promises.Promise{``5},Proto.Promises.Promise{``6},Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`7"/> that will resolve with the values of the promises when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Race(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the promises has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Race(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the promises has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Race(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the promises has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Race(Proto.Promises.Promise[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Race(System.Collections.Generic.IEnumerable{Proto.Promises.Promise})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.Race``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex(Proto.Promises.Promise[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex(System.Collections.Generic.IEnumerable{Proto.Promises.Promise})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.First(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the promises has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.First(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the promises has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.First(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the promises has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.First(Proto.Promises.Promise[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.First(System.Collections.Generic.IEnumerable{Proto.Promises.Promise})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.First``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex(Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex(Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise,Proto.Promises.Promise)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex(Proto.Promises.Promise[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex(System.Collections.Generic.IEnumerable{Proto.Promises.Promise})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve when the first of the <paramref name="promises"/> has resolved.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.Int32"/> that will resolve when the first of the promises has resolved with the index of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``1(Proto.Promises.Promise{``0},Proto.Promises.Promise{``0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``1(Proto.Promises.Promise{``0},Proto.Promises.Promise{``0},Proto.Promises.Promise{``0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``1(Proto.Promises.Promise{``0},Proto.Promises.Promise{``0},Proto.Promises.Promise{``0},Proto.Promises.Promise{``0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``1(Proto.Promises.Promise{``0}[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``1(System.Collections.Generic.IEnumerable{Proto.Promises.Promise{``0}})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.RaceWithIndex``2(``1)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``1(Proto.Promises.Promise{``0},Proto.Promises.Promise{``0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``1(Proto.Promises.Promise{``0},Proto.Promises.Promise{``0},Proto.Promises.Promise{``0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``1(Proto.Promises.Promise{``0},Proto.Promises.Promise{``0},Proto.Promises.Promise{``0},Proto.Promises.Promise{``0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``1(Proto.Promises.Promise{``0}[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``1(System.Collections.Generic.IEnumerable{Proto.Promises.Promise{``0}})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.FirstWithIndex``2(``1)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> of <see cref="T:System.ValueTuple`2"/> that will resolve when the first of the promises has resolved with the index and result of that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise.ResultContainer">
            <summary>
            Used to get the state and/or reason of a settled <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise.ResultContainer._target">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ResultContainer.#ctor(System.Object,Proto.Promises.Promise.State)">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ResultContainer.#ctor(Proto.Promises.Promise{Proto.Promises.Internal.VoidResult}.ResultContainer)">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ResultContainer.RethrowIfRejectedOrCanceled">
            <summary>
            If the <see cref="T:Proto.Promises.Promise"/> is rejected or canceled, rethrow the reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ResultContainer.RethrowIfRejected">
            <summary>
            If the <see cref="T:Proto.Promises.Promise"/> is rejected, rethrow the rejection.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise.ResultContainer.RethrowIfCanceled">
            <summary>
            If the <see cref="T:Proto.Promises.Promise"/> is canceled, rethrow the cancelation.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.ResultContainer.State">
            <summary>
            Get the state of the <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise.ResultContainer.RejectReason">
            <summary>
            Gets the reason of the rejected <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise`1">
            <summary>
            A <see cref="T:Proto.Promises.Promise`1"/> represents the eventual result of an asynchronous operation.
            The primary ways of interacting with a <see cref="T:Proto.Promises.Promise`1"/> are via the `await` keyword in an async function,
            or its then method, which registers callbacks to be invoked with its resolve value when the <see cref="T:Proto.Promises.Promise`1"/> is resolved,
            or the reason why the <see cref="T:Proto.Promises.Promise`1"/> cannot be resolved.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.GetAwaiter">
            <summary>Gets an awaiter for this <see cref="T:Proto.Promises.Promise`1"/>.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>The awaiter.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.AwaitNoThrow">
            <summary>Gets an awaiter for this <see cref="T:Proto.Promises.Promise`1"/> that suppresses throws and returns a <see cref="T:Proto.Promises.Promise`1.ResultContainer"/> instead.</summary>
            <returns>The awaiter.</returns>
            <remarks>Use as `var resultContainer = await promise.AwaitNoThrow();`</remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.AwaitWithProgress(System.Single,System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise`1"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function.
            The progress reported will be lerped from <paramref name="minProgress"/> to <paramref name="maxProgress"/>. Both values must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>Use as `await promise.AwaitWithProgress(minProgress, maxProgress);`</remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.AwaitWithProgress(System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise`1"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function.
            The progress reported will be lerped from its current progress to <paramref name="maxProgress"/>. <paramref name="maxProgress"/> must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>
            If the previously awaited promise did not complete successfully, minProgress will be set to the previous <paramref name="maxProgress"/> instead of current.
            <para/>Use as `await promise.AwaitWithProgress(maxProgress);`
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.AwaitWithProgressNoThrow(System.Single,System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise`1"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function,
            and suppresses throws and returns a <see cref="T:Proto.Promises.Promise`1.ResultContainer"/> instead.
            The progress reported will be lerped from <paramref name="minProgress"/> to <paramref name="maxProgress"/>. Both values must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>Use as `var resultContainer = await promise.AwaitWithProgressNoThrow(minProgress, maxProgress);`</remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.AwaitWithProgressNoThrow(System.Single)">
            <summary>
            Gets an awaiter for this <see cref="T:Proto.Promises.Promise`1"/> that supports reporting progress to the async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/> function,
            and suppresses throws and returns a <see cref="T:Proto.Promises.Promise`1.ResultContainer"/> instead.
            The progress reported will be lerped from its current progress to <paramref name="maxProgress"/>. <paramref name="maxProgress"/> must be between 0 and 1 inclusive.
            </summary>
            <returns>The awaiter.</returns>
            <remarks>
            If the previously awaited promise did not complete successfully, minProgress will be set to the previous <paramref name="maxProgress"/> instead of current.
            <para/>Use as `var resultContainer = await promise.AwaitWithProgressNoThrow(maxProgress);`
            </remarks>
        </member>
        <member name="T:Proto.Promises.Promise`1.Deferred">
            <summary>
            An instance of this is used to report progress and resolve, reject, or cancel the attached <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.Deferred.Promise">
            <summary>
            The attached <see cref="T:Proto.Promises.Promise`1"/> that this controls.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.Deferred.IsValid">
            <summary>
            Get whether or not this instance and the attached <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/> are valid.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.Deferred.IsValidAndPending">
            <summary>
            Get whether or not this instance is valid and the attached <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/> is still pending.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.#ctor(Proto.Promises.Internal.PromiseRefBase.DeferredPromise{`0},System.Int16,System.Int32)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.New">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1.Deferred"/> instance that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.New(Proto.Promises.CancelationToken)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1.Deferred"/> instance that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If the <paramref name="cancelationToken"/> is canceled while the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is pending, it and the <see cref="T:Proto.Promises.Promise"/> will be canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.Resolve(`0)">
            <summary>
            Resolve the linked <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/> with <paramref name="value"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.TryResolve(`0)">
            <summary>
            Try to resolve the linked <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/> with <paramref name="value"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.Reject``1(``0)">
            <summary>
            Reject the linked <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/> with <paramref name="reason"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.TryReject``1(``0)">
            <summary>
            Try to reject the linked <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/> with <paramref name="reason"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.Cancel">
            <summary>
            Cancel the linked <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/>.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.TryCancel">
            <summary>
            Try to cancel the linked <see cref="P:Proto.Promises.Promise`1.Deferred.Promise"/>.
            <para/> Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.ReportProgress(System.Single)">
            <summary>
            Report progress between 0 and 1.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException"/>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.TryReportProgress(System.Single)">
            <summary>
            Try to report progress between 0 and 1.
            <para/> Returns true if successful, false otherwise.
            </summary>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"/>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.op_Implicit(Proto.Promises.Promise{`0}.Deferred)~Proto.Promises.Promise.DeferredBase">
            <summary>
            Cast to <see cref="T:Proto.Promises.Promise.DeferredBase"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.op_Explicit(Proto.Promises.Promise.DeferredBase)~Proto.Promises.Promise{`0}.Deferred">
            <summary>
            Cast <see cref="T:Proto.Promises.Promise.DeferredBase"/> to <see cref="T:Proto.Promises.Promise`1.Deferred"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.Equals(Proto.Promises.Promise{`0}.Deferred)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.Promise`1.Deferred"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.op_Equality(Proto.Promises.Promise{`0}.Deferred,Proto.Promises.Promise{`0}.Deferred)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise`1.Deferred"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Deferred.op_Inequality(Proto.Promises.Promise{`0}.Deferred,Proto.Promises.Promise{`0}.Deferred)">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise`1.Deferred"/> values are not equal.</summary>
        </member>
        <member name="T:Proto.Promises.Promise`1.ContinueAction">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise`1.ContinueWith(Proto.Promises.Promise{`0}.ContinueAction,Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="T:Proto.Promises.Promise`1.ContinueAction`1">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise`1.ContinueWith``1(``0,Proto.Promises.Promise{`0}.ContinueAction{``0},Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="capturedValue">The value that was passed to <see cref="M:Proto.Promises.Promise`1.ContinueWith``1(``0,Proto.Promises.Promise{`0}.ContinueAction{``0},Proto.Promises.CancelationToken)"/>.</param>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="T:Proto.Promises.Promise`1.ContinueFunc`1">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise`1.ContinueWith``1(Proto.Promises.Promise{`0}.ContinueFunc{``0},Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="T:Proto.Promises.Promise`1.ContinueFunc`2">
            <summary>
            The delegate type used for <see cref="M:Proto.Promises.Promise`1.ContinueWith``2(``0,Proto.Promises.Promise{`0}.ContinueFunc{``0,``1},Proto.Promises.CancelationToken)"/>.
            </summary>
            <param name="capturedValue">The value that was passed to <see cref="M:Proto.Promises.Promise`1.ContinueWith``2(``0,Proto.Promises.Promise{`0}.ContinueFunc{``0,``1},Proto.Promises.CancelationToken)"/>.</param>
            <param name="resultContainer">The container from which the promise's state and result or reason can be extracted.</param>
        </member>
        <member name="F:Proto.Promises.Promise`1._ref">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise`1._result">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise`1._id">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.Depth">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.#ctor(Proto.Promises.Internal.PromiseRefBase.PromiseRef{`0},System.Int16,System.UInt16)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.#ctor(Proto.Promises.Internal.PromiseRefBase.PromiseRef{`0},System.Int16,System.UInt16,`0)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.#ctor(`0)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach(System.Collections.Generic.IEnumerable{`0},System.Func{`0,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <param name="source">An enumerable data source.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach(System.Collections.Generic.IEnumerable{`0},System.Func{`0,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel.</summary>
            <param name="source">An enumerable data source.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach``1(System.Collections.Generic.IEnumerable{`0},``0,System.Func{`0,``0,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <typeparam name="TCapture">The type of the captured value.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach``1(System.Collections.Generic.IEnumerable{`0},``0,System.Func{`0,``0,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in which iterations may run in parallel.</summary>
            <typeparam name="TCapture">The type of the captured value.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach``1(``0,System.Func{`0,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerator`1"/> in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach``1(``0,System.Func{`0,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerator`1"/> in which iterations may run in parallel.</summary>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach``2(``0,``1,System.Func{`0,``1,Proto.Promises.CancelationToken,Proto.Promises.Promise},Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerator`1"/> in which iterations may run in parallel on <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.</summary>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
            <typeparam name="TCapture">The type of the captured value.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.ParallelForEach``2(``0,``1,System.Func{`0,``1,Proto.Promises.CancelationToken,Proto.Promises.Promise},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Int32)">
            <summary>Executes a for each operation on an <see cref="T:System.Collections.Generic.IEnumerator`1"/> in which iterations may run in parallel.</summary>
            <typeparam name="TEnumerator">The type of the enumerator.</typeparam>
            <typeparam name="TCapture">The type of the captured value.</typeparam>
            <param name="source">An enumerable data source.</param>
            <param name="captureValue">The captured value that will be passed to the <paramref name="body"/>.</param>
            <param name="body">An asynchronous delegate that is invoked once per element in the data source.</param>
            <param name="synchronizationContext">The synchronization context on which the iterations will be ran. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="cancelationToken">A cancelation token that may be used to cancel the for each operation.</param>
            <param name="maxDegreeOfParallelism">The maximum number of concurrent iterations. If -1, this value will be set to <see cref="P:System.Environment.ProcessorCount"/>.</param>
            <exception cref="T:System.ArgumentNullException">The exception that is thrown when the <paramref name="source"/> argument or <paramref name="body"/> argument is null.</exception>
            <returns>A promise that represents the entire for each operation.</returns>
        </member>
        <member name="P:Proto.Promises.Promise`1.IsValid">
            <summary>
            Gets whether this instance is valid to be awaited.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.AsPromise">
            <summary>
            Cast to <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.op_Implicit(Proto.Promises.Promise{`0})~Proto.Promises.Promise">
            <summary>
            Cast to <see cref="T:Proto.Promises.Promise"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Preserve">
            <summary>
            Mark this as awaited and get a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/> that inherits the state of this and can be awaited multiple times until <see cref="M:Proto.Promises.Promise`1.Forget"/> is called on it.
            <para/><see cref="M:Proto.Promises.Promise`1.Forget"/> must be called when you are finished with it.
            <para/>NOTE: You should not return a preserved <see cref="T:Proto.Promises.Promise`1"/> from a public API. Use <see cref="M:Proto.Promises.Promise`1.Duplicate"/> to get a <see cref="T:Proto.Promises.Promise`1"/> that is publicly safe.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Forget">
            <summary>
            Mark this as awaited and prevent any further awaits or callbacks on this.
            <para/>NOTE: It is imperative to terminate your promise chains with Forget so that any uncaught rejections will be reported and objects repooled (if pooling is enabled).
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.WaitForResult">
            <summary>
            Mark this as awaited and wait for the operation to complete. Returns the result of the operation.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!</remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.WaitForResultNoThrow">
            <summary>
            Mark this as awaited and wait for the operation to complete, without throwing. Returns a <see cref="T:Proto.Promises.Promise`1.ResultContainer"/> that wraps the completion state and result or reason of the operation.
            </summary>
            <remarks>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!</remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.WaitForResult(System.TimeSpan,`0@)">
            <summary>
            Mark this as awaited and wait for the operation to complete with a specified timeout.
            <para/>If the operation completed successfully before the timeout expired, this will return <see langword="true"/> and <paramref name="result"/> will be assigned from the result of the operation. Otherwise, this will return <see langword="false"/>.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>
            If a <see cref="T:System.TimeSpan"/> representing -1 millisecond is specified for the timeout parameter, this method blocks indefinitely until the operation is complete.
            <para/>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.TryWaitForResult(System.TimeSpan,`0@)">
            <summary>
            Mark this as awaited and wait for the operation to complete with a specified timeout.
            <para/>If the operation completed successfully before the timeout expired, this will return <see langword="true"/> and <paramref name="result"/> will be assigned from the result of the operation. Otherwise, this will return <see langword="false"/>.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>
            If a <see cref="T:System.TimeSpan"/> representing -1 millisecond is specified for the timeout parameter, this method blocks indefinitely until the operation is complete.
            <para/>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.TryWaitForResultNoThrow(System.TimeSpan,Proto.Promises.Promise{`0}.ResultContainer@)">
            <summary>
            Mark this as awaited and wait for the operation to complete with a specified timeout, without throwing.
            <para/>If the operation completed successfully before the timeout expired, this will return <see langword="true"/> and <paramref name="resultContainer"/> will be assigned from the result of the operation. Otherwise, this will return <see langword="false"/>.
            If the operation was rejected or canceled, the appropriate exception will be thrown.
            </summary>
            <remarks>
            If a <see cref="T:System.TimeSpan"/> representing -1 millisecond is specified for the timeout parameter, this method blocks indefinitely until the operation is complete.
            <para/>Warning: this may cause a deadlock if you are not careful. Make sure you know what you are doing!
            </remarks>
        </member>
        <member name="M:Proto.Promises.Promise`1.Duplicate">
            <summary>
            Mark this as awaited and get a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/> that inherits the state of this and can be awaited once.
            <para/>Preserved promises are unsafe to return from public APIs. Use <see cref="M:Proto.Promises.Promise`1.Duplicate"/> to get a <see cref="T:Proto.Promises.Promise`1"/> that is publicly safe.
            <para/><see cref="M:Proto.Promises.Promise`1.Duplicate"/> is safe to call even if you are unsure if this is preserved.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.WaitAsync(Proto.Promises.SynchronizationOption,System.Boolean,Proto.Promises.CancelationToken)">
            <summary>
            Mark this as awaited and schedule the next continuation to execute on the context of the provided <paramref name="continuationOption"/>.
            Returns a new <see cref="T:Proto.Promises.Promise`1"/> that inherits the state of this, or will be canceled if/when the <paramref name="cancelationToken"/> is canceled before this is complete.
            </summary>
            <param name="continuationOption">Indicates on which context the next continuation will be executed.</param>
            <param name="forceAsync">If true, forces the next continuation to be invoked asynchronously. If <paramref name="continuationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled before this is complete, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and the cancelation will propagate on the context of the provided <paramref name="continuationOption"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.WaitAsync(System.Threading.SynchronizationContext,System.Boolean,Proto.Promises.CancelationToken)">
            <summary>
            Mark this as awaited and schedule the next continuation to execute on <paramref name="continuationContext"/>.
            Returns a new <see cref="T:Proto.Promises.Promise`1"/> that inherits the state of this, or will be canceled if/when the <paramref name="cancelationToken"/> is canceled before this is complete.
            </summary>
            <param name="continuationContext">The context on which context the next continuation will be executed. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the next continuation to be invoked asynchronously.</param>
            <param name="cancelationToken">If canceled before this is complete, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and the cancelation will propagate on the provided <paramref name="continuationContext"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.WaitAsync(Proto.Promises.CancelationToken)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1"/> that inherits the state of this, or will be canceled if/when the <paramref name="cancelationToken"/> is canceled before the continuation is invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Progress``1(``0,Proto.Promises.SynchronizationOption,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            
            <para/>If/when this is resolved, <paramref name="progressListener"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
            <param name="progressListener">Will be reported with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeOption">Indicates on which context <paramref name="progressListener"/> will be reported.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously. If <paramref name="invokeOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Progress``1(``0,System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            
            <para/>If/when this is resolved, <paramref name="progressListener"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
            <param name="progressListener">Will be reported with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeContext">The context on which <paramref name="progressListener"/> will be reported. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Progress(System.Action{System.Single},Proto.Promises.SynchronizationOption,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
            <param name="onProgress">Will be invoked with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeOption">Indicates on which context <paramref name="onProgress"/> will be invoked.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously. If <paramref name="invokeOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Progress(System.Action{System.Single},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with 1.0, then the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
            <param name="onProgress">Will be invoked with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeContext">The context on which <paramref name="onProgress"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Finally(System.Action)">
            <summary>
            Add a finally callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onFinally"/> will be invoked.
            <para/>If <paramref name="onFinally"/> throws an exception, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that exception,
            otherwise it will be resolved, rejected, or canceled with the same value or reason as this.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation(System.Func{`0},Proto.Promises.CancelationToken)">
            <summary>
            Add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the same value.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation(System.Func{Proto.Promises.Promise{`0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the same value.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Action{`0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Func{`0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch(System.Func{`0},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(System.Func{``0,`0},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch(System.Func{Proto.Promises.Promise{`0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(System.Func{``0,Proto.Promises.Promise{`0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
            <para/>If/when this is canceled or rejected with any other reason or no reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Action{`0},System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action{`0},System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,``0},System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,``0},System.Func{``1,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Func{`0,Proto.Promises.Promise},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise},System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise{``0}},System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,Proto.Promises.Promise{``0}},System.Func{``1,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Action{`0},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action{`0},System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,``0},System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,``0},System.Func{``1,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Func{`0,Proto.Promises.Promise},System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise},System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise{``0}},System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,Proto.Promises.Promise{``0}},System.Func{``1,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith(Proto.Promises.Promise{`0}.ContinueAction,Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith``1(Proto.Promises.Promise{`0}.ContinueFunc{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith(Proto.Promises.Promise{`0}.ContinueFunc{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith``1(Proto.Promises.Promise{`0}.ContinueFunc{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Progress``1(``0,System.Action{``0,System.Single},Proto.Promises.SynchronizationOption,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Capture a value and add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with <paramref name="progressCaptureValue"/> and 1.0, then the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
            <param name="progressCaptureValue">The value that will be passed to <paramref name="onProgress"/>.</param>
            <param name="onProgress">Will be invoked with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeOption">Indicates on which context <paramref name="onProgress"/> will be invoked.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously. If <paramref name="invokeOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Progress``1(``0,System.Action{``0,System.Single},System.Threading.SynchronizationContext,Proto.Promises.CancelationToken,System.Boolean)">
            <summary>
            Capture a value and add a progress listener. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            
            <para/>If/when this is resolved, <paramref name="onProgress"/> will be invoked with <paramref name="progressCaptureValue"/> and 1.0, then the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
            <param name="progressCaptureValue">The value that will be passed to <paramref name="onProgress"/>.</param>
            <param name="onProgress">Will be invoked with progress that is normalized between 0 and 1 on the context of the provided option.</param>
            <param name="invokeContext">The context on which <paramref name="onProgress"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces progress invoke to happen asynchronously.</param>
            <param name="cancelationToken">If canceled while this is pending, progress will stop being reported. This will not cancel the returned <see cref="T:Proto.Promises.Promise"/>.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Finally``1(``0,System.Action{``0})">
            <summary>
            Capture a value and add a finally callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
            <para/>When this is resolved, rejected, or canceled, <paramref name="onFinally"/> will be invoked with <paramref name="finallyCaptureValue"/>.
            <para/>If <paramref name="onFinally"/> throws an exception, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that exception,
            otherwise it will be resolved, rejected, or canceled with the same value or reason as this.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation``1(``0,System.Func{``0,`0},Proto.Promises.CancelationToken)">
            <summary>
            Capture a value and add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the same value.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation``1(``0,System.Func{``0,Proto.Promises.Promise{`0}},Proto.Promises.CancelationToken)">
            <summary>
            Capture a value and add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the same value.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Action{``0,`0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Func{``0,`0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(``0,System.Func{``0,`0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``2(``0,System.Func{``0,``1,`0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(``0,System.Func{``0,Proto.Promises.Promise{`0}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``2(``0,System.Func{``0,``1,Proto.Promises.Promise{`0}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="T"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the resolve value.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Action{``0,`0},System.Action,Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action{`0},``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0,`0},``1,System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0,`0},System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Action{`0},``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Action{``0,`0},``1,System.Action{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,``1},System.Func{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,``1},``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,``2},``1,System.Func{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,``1},System.Func{``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{`0,``1},``0,System.Func{``0,``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,`0,``2},``1,System.Func{``1,``3,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Func{``0,`0,Proto.Promises.Promise},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise},``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise},``1,System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise},System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,Proto.Promises.Promise},``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,Proto.Promises.Promise},``1,System.Func{``1,``2,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise{``1}},System.Func{Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,Proto.Promises.Promise{``1}},``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,Proto.Promises.Promise{``2}},``1,System.Func{``1,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,Proto.Promises.Promise{``1}},System.Func{``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{`0,Proto.Promises.Promise{``1}},``0,System.Func{``0,``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,`0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``3,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Action{``0,`0},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action{`0},``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0,`0},``1,System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0,`0},System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Action{`0},``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Action{``0,`0},``1,System.Func{``1,``2,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,``1},System.Func{Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,``1},``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,``2},``1,System.Func{``1,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,``1},System.Func{``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{`0,``1},``0,System.Func{``0,``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,`0,``2},``1,System.Func{``1,``3,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Func{``0,`0,Proto.Promises.Promise},System.Action,Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{`0,Proto.Promises.Promise},``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise},``1,System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise},System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,Proto.Promises.Promise},``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,Proto.Promises.Promise},``1,System.Action{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,`0,Proto.Promises.Promise{``1}},System.Func{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{`0,Proto.Promises.Promise{``1}},``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,`0,Proto.Promises.Promise{``1}},System.Func{``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{`0,Proto.Promises.Promise{``1}},``0,System.Func{``0,``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,`0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``3,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/> and the resolve value, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith``1(``0,Proto.Promises.Promise{`0}.ContinueAction{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith``2(``0,Proto.Promises.Promise{`0}.ContinueFunc{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith``1(``0,Proto.Promises.Promise{`0}.ContinueFunc{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ContinueWith``2(``0,Proto.Promises.Promise{`0}.ContinueFunc{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Add a continuation callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>When this is resolved, rejected, or canceled, <paramref name="onContinue"/> will be invoked with <paramref name="continueCaptureValue"/> and the <see cref="T:Proto.Promises.Promise`1.ResultContainer"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onContinue"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation(System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation(System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch(System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch(System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Action,System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action,System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{``0},System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{``0},System.Func{``1,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Func{Proto.Promises.Promise},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise},System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise{``0}},System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{Proto.Promises.Promise{``0}},System.Func{``1,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Action,System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{``0},System.Func{Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{``0},System.Func{``1,Proto.Promises.Promise{``0}},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then(System.Func{Proto.Promises.Promise},System.Action,Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise},System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise{``0}},System.Func{``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{Proto.Promises.Promise{``0}},System.Func{``1,``0},Proto.Promises.CancelationToken)">
            <summary>
            Add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
            <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
            If if throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
            <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation``1(``0,System.Action{``0},Proto.Promises.CancelationToken)">
            <summary>
            Capture a value and add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.CatchCancelation``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
            <summary>
            Capture a value and add a cancel callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
            <para/>If/when this is canceled, <paramref name="onCanceled"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
            If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>, unless it is a Special Exception (see README).
            <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
            <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
            
            <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onCanceled"/> will not be invoked.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``2(``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``1(``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Catch``2(``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, the new <see cref="T:Proto.Promises.Promise"/> will be resolved.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Action{``0},System.Action,Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action,``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0},``1,System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0},System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Action,``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Action{``0},``1,System.Action{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,``1},System.Func{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{``1},``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,``2},``1,System.Func{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,``1},System.Func{``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{``1},``0,System.Func{``0,``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,``2},``1,System.Func{``1,``3,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Func{``0,Proto.Promises.Promise},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise},``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise},System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{Proto.Promises.Promise},``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Func{``1,``2,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``3,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Action{``0},System.Func{Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Action,``0,System.Func{``0,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0},``1,System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Action{``0},System.Func{``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Action,``0,System.Func{``0,``1,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Action{``0},``1,System.Func{``1,``2,Proto.Promises.Promise},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,``1},System.Func{Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{``1},``0,System.Func{``0,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,``2},``1,System.Func{``1,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,``1},System.Func{``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{``1},``0,System.Func{``0,``2,Proto.Promises.Promise{``1}},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,``2},``1,System.Func{``1,``3,Proto.Promises.Promise{``2}},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(``0,System.Func{``0,Proto.Promises.Promise},System.Action,Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``1(System.Func{Proto.Promises.Promise},``0,System.Action{``0},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise},System.Action{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{Proto.Promises.Promise},``0,System.Action{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,Proto.Promises.Promise},``1,System.Action{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise"/> will be resolved when it returns.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``2(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(``0,System.Func{``0,Proto.Promises.Promise{``1}},System.Func{``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``3(System.Func{Proto.Promises.Promise{``1}},``0,System.Func{``0,``2,``1},Proto.Promises.CancelationToken)">
             <summary>
             Capture a value and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Then``4(``0,System.Func{``0,Proto.Promises.Promise{``2}},``1,System.Func{``1,``3,``2},Proto.Promises.CancelationToken)">
             <summary>
             Capture 2 values and add a resolve and a reject callback. Returns a new <see cref="T:Proto.Promises.Promise`1"/> of <typeparamref name="TResult"/>.
             <para/>If/when this is resolved, <paramref name="onResolved"/> will be invoked with <paramref name="resolveCaptureValue"/>, and the new <see cref="T:Proto.Promises.Promise`1"/> will adopt the state of the returned <see cref="T:Proto.Promises.Promise`1"/>.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             <para/>If/when this is rejected with any reason that is assignable to <typeparamref name="TReject"/>, <paramref name="onRejected"/> will be invoked with <paramref name="rejectCaptureValue"/> and that reason, and the new <see cref="T:Proto.Promises.Promise`1"/> will be resolved with the returned value.
             If it throws an <see cref="T:System.Exception"/>, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with that <see cref="T:System.Exception"/>.
             If this is rejected with any other reason, the new <see cref="T:Proto.Promises.Promise`1"/> will be rejected with the same reason.
             <para/>If/when this is canceled, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            
             <para/>If the <paramref name="cancelationToken"/> is canceled while this is pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled, and <paramref name="onResolved"/> and <paramref name="onRejected"/> will not be invoked.
             </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Equals(Proto.Promises.Promise{`0})">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:Proto.Promises.Promise`1"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Equals(System.Object)">
            <summary>Returns a value indicating whether this value is equal to a specified <see cref="T:System.Object"/>.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.op_Equality(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise`1"/> values are equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.op_Inequality(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>Returns a value indicating whether two <see cref="T:Proto.Promises.Promise`1"/> values are not equal.</summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ToString">
            <summary>
            Gets the string representation of this instance.
            </summary>
            <returns>The string representation of this instance.</returns>
        </member>
        <member name="M:Proto.Promises.Promise`1.Race(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the promises has resolved with the same value as that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Race(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the promises has resolved with the same value as that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Race(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the promises has resolved with the same value as that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Race(Proto.Promises.Promise{`0}[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the <paramref name="promises"/> has resolved with the same value as that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Race(System.Collections.Generic.IEnumerable{Proto.Promises.Promise{`0}})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the <paramref name="promises"/> has resolved with the same value as that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Race``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the <paramref name="promises"/> has resolved with the same value as that promise.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.First(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the promises has resolved with the same value as that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.First(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the promises has resolved with the same value as that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.First(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the promises has resolved with the same value as that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.First(Proto.Promises.Promise{`0}[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the <paramref name="promises"/> has resolved with the same value as that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.First(System.Collections.Generic.IEnumerable{Proto.Promises.Promise{`0}})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the <paramref name="promises"/> has resolved with the same value as that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.First``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve when the first of the <paramref name="promises"/> has resolved with the same value as that promise.
            If all promises are rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will be canceled or rejected with the same reason as the last <see cref="T:Proto.Promises.Promise`1"/> that is rejected or canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.All(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},System.Collections.Generic.IList{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve with a list of the promises' values in the same order when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
            <param name="promise1">The first promise to combine.</param>
            <param name="promise2">The second promise to combine.</param>
            <param name="valueContainer">Optional list that will be used to contain the resolved values. If it is not provided, a new one will be created.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.All(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},System.Collections.Generic.IList{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve with a list of the promises' values in the same order when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
            <param name="promise1">The first promise to combine.</param>
            <param name="promise2">The second promise to combine.</param>
            <param name="promise3">The third promise to combine.</param>
            <param name="valueContainer">Optional list that will be used to contain the resolved values. If it is not provided, a new one will be created.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.All(Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},Proto.Promises.Promise{`0},System.Collections.Generic.IList{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise"/> that will resolve with a list of the promises' values in the same order when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise"/> will immediately be canceled or rejected with the same reason.
            </summary>
            <param name="promise1">The first promise to combine.</param>
            <param name="promise2">The second promise to combine.</param>
            <param name="promise3">The third promise to combine.</param>
            <param name="promise4">The fourth promise to combine.</param>
            <param name="valueContainer">Optional list that will be used to contain the resolved values. If it is not provided, a new one will be created.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.All(Proto.Promises.Promise{`0}[])">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve with a list of values in the same order as <paramref name="promises"/> when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.All(Proto.Promises.Promise{`0}[],System.Collections.Generic.IList{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve with a list of values in the same order as <paramref name="promises"/> when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
            <param name="promises">The promises to combine.</param>
            <param name="valueContainer">Optional list that will be used to contain the resolved values. If it is not provided, a new one will be created.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.All(System.Collections.Generic.IEnumerable{Proto.Promises.Promise{`0}},System.Collections.Generic.IList{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve with a list of values in the same order as <paramref name="promises"/>s when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
            <param name="promises">The promises to combine.</param>
            <param name="valueContainer">Optional list that will be used to contain the resolved values. If it is not provided, a new one will be created.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.All``1(``0,System.Collections.Generic.IList{`0})">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that will resolve a list of values in the same order as <paramref name="promises"/> when they have all resolved.
            If any promise is rejected or canceled, the returned <see cref="T:Proto.Promises.Promise`1"/> will immediately be canceled or rejected with the same reason.
            </summary>
            <param name="promises">The enumerator of promises to combine.</param>
            <param name="valueContainer">Optional list that will be used to contain the resolved values. If it is not provided, a new one will be created.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.New(System.Action{Proto.Promises.Promise{`0}.Deferred},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1"/>. <paramref name="resolver"/> is invoked with a <see cref="T:Proto.Promises.Promise`1.Deferred"/> that controls the state of the new <see cref="T:Proto.Promises.Promise`1"/>.
            You may provide a <paramref name="synchronizationOption"/> to control the context on which the <paramref name="resolver"/> is invoked.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>
            </summary>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise`1.Deferred"/>.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="resolver"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.New``1(``0,System.Action{``0,Proto.Promises.Promise{`0}.Deferred},Proto.Promises.SynchronizationOption,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1"/>. <paramref name="resolver"/> is invoked with <paramref name="captureValue"/> and a <see cref="T:Proto.Promises.Promise`1.Deferred"/> that controls the state of the new <see cref="T:Proto.Promises.Promise`1"/>.
            You may provide a <paramref name="synchronizationOption"/> to control the context on which the <paramref name="resolver"/> is invoked.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="resolver"/>.</param>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise`1.Deferred"/>.</param>
            <param name="synchronizationOption">Indicates on which context the <paramref name="resolver"/> will be invoked.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously. If <paramref name="synchronizationOption"/> is <see cref="F:Proto.Promises.SynchronizationOption.Synchronous"/>, this value will be ignored.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.New(System.Action{Proto.Promises.Promise{`0}.Deferred},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1"/>. <paramref name="resolver"/> is invoked with a <see cref="T:Proto.Promises.Promise`1.Deferred"/> that controls the state of the new <see cref="T:Proto.Promises.Promise`1"/> on the provided <paramref name="synchronizationContext"/>.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>
            </summary>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise`1.Deferred"/>.</param>
            <param name="synchronizationContext">The context on which the <paramref name="resolver"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.New``1(``0,System.Action{``0,Proto.Promises.Promise{`0}.Deferred},System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Returns a new <see cref="T:Proto.Promises.Promise`1"/>. <paramref name="resolver"/> is invoked with <paramref name="captureValue"/> and a <see cref="T:Proto.Promises.Promise`1.Deferred"/> that controls the state of the new <see cref="T:Proto.Promises.Promise`1"/> on the provided <paramref name="synchronizationContext"/>.
            <para/>If <paramref name="resolver"/> throws an <see cref="T:System.Exception"/> and the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is still pending, the new <see cref="T:Proto.Promises.Promise`1"/> will be canceled if it is an <see cref="T:System.OperationCanceledException"/>,
            or rejected with that <see cref="T:System.Exception"/>
            </summary>
            <param name="captureValue">The value that will be passed to <paramref name="resolver"/>.</param>
            <param name="resolver">The resolver delegate that will control the completion of the returned <see cref="T:Proto.Promises.Promise"/> via the passed in <see cref="T:Proto.Promises.Promise`1.Deferred"/>.</param>
            <param name="synchronizationContext">The context on which the <paramref name="resolver"/> will be invoked. If null, <see cref="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)"/> will be used.</param>
            <param name="forceAsync">If true, forces the <paramref name="resolver"/> to be invoked asynchronously.</param>
        </member>
        <member name="M:Proto.Promises.Promise`1.Resolved(`0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that is already resolved with <paramref name="value"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Rejected``1(``0)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that is already rejected with <paramref name="reason"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.Canceled">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1"/> that is already canceled.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.NewDeferred">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1.Deferred"/> object that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.NewDeferred(Proto.Promises.CancelationToken)">
            <summary>
            Returns a <see cref="T:Proto.Promises.Promise`1.Deferred"/> object that is linked to and controls the state of a new <see cref="T:Proto.Promises.Promise`1"/>.
            <para/>If the <paramref name="cancelationToken"/> is canceled while the <see cref="T:Proto.Promises.Promise`1.Deferred"/> is pending, it and the <see cref="T:Proto.Promises.Promise`1"/> will be canceled.
            </summary>
        </member>
        <member name="T:Proto.Promises.Promise`1.ResultContainer">
            <summary>
            Used to get the state and result or reason of a settled <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="F:Proto.Promises.Promise`1.ResultContainer._rejectContainer">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ResultContainer.#ctor(`0,System.Object,Proto.Promises.Promise.State)">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ResultContainer.RethrowIfRejectedOrCanceled">
            <summary>
            If the <see cref="T:Proto.Promises.Promise`1"/> is rejected or canceled, rethrow the reason.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ResultContainer.RethrowIfRejected">
            <summary>
            If the <see cref="T:Proto.Promises.Promise`1"/> is rejected, rethrow the rejection.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ResultContainer.RethrowIfCanceled">
            <summary>
            If the <see cref="T:Proto.Promises.Promise`1"/> is canceled, rethrow the cancelation.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.ResultContainer.State">
            <summary>
            Get the state of the <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.ResultContainer.Result">
            <summary>
            Gets the result of the resolved <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="P:Proto.Promises.Promise`1.ResultContainer.RejectReason">
            <summary>
            Gets the reason of the rejected <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Promise`1.ResultContainer.op_Implicit(Proto.Promises.Promise{`0}.ResultContainer)~Proto.Promises.Promise.ResultContainer">
            <summary>
            Cast to <see cref="T:Proto.Promises.Promise.ResultContainer"/>.
            </summary>
        </member>
        <member name="T:Proto.Promises.ArrayExtensions.Enumerator`1">
            <summary>
            Generic Array enumerator. Use this instead of the default <see cref="M:System.Array.GetEnumerator"/> for passing it around as an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise"/>.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid.#ctor(Proto.Promises.Promise)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise"/>.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1.#ctor(Proto.Promises.Promise{`0})">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise`1"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise`1"/>.</summary>
            <returns>The result of the completed <see cref="T:Proto.Promises.Promise`1"/></returns>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise"/>, without throwing.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid.#ctor(Proto.Promises.Promise)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise"/>.</summary>
            <returns>A <see cref="T:Proto.Promises.Promise.ResultContainer"/> that wraps the completion state and reason of the <see cref="T:Proto.Promises.Promise"/>.</returns>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiterVoid.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise`1"/>, without throwing.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1.#ctor(Proto.Promises.Promise{`0})">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise`1"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise`1"/>.</summary>
            <returns>A <see cref="T:Proto.Promises.Promise`1.ResultContainer"/> that wraps the completion state and result or reason of the <see cref="T:Proto.Promises.Promise`1"/>.</returns>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseNoThrowAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise"/> and reporting its progress to the associated async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid.#ctor(Proto.Promises.Promise,System.Single,System.Single)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise"/>.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise`1"/> and reporting its progress to the associated async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1.#ctor(Proto.Promises.Promise{`0},System.Single,System.Single)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise`1"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise`1"/>.</summary>
            <returns>The result of the completed <see cref="T:Proto.Promises.Promise`1"/></returns>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseProgressAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise"/> and reporting its progress to the associated async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/>, without throwing.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid.#ctor(Proto.Promises.Promise,System.Single,System.Single)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise"/>.</summary>
            <returns>A <see cref="T:Proto.Promises.Promise.ResultContainer"/> that wraps the completion state and reason of the <see cref="T:Proto.Promises.Promise"/>.</returns>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiterVoid.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiterVoid"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1">
            <summary>
            Provides an awaiter for awaiting a <see cref="T:Proto.Promises.Promise`1"/> and reporting its progress to the associated async <see cref="T:Proto.Promises.Promise"/> or <see cref="T:Proto.Promises.Promise`1"/>, without throwing.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1.#ctor(Proto.Promises.Promise{`0},System.Single,System.Single)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise`1"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1.GetResult">
            <summary>Ends the await on the completed <see cref="T:Proto.Promises.Promise`1"/>.</summary>
            <returns>A <see cref="T:Proto.Promises.Promise`1.ResultContainer"/> that wraps the completion state and result or reason of the <see cref="T:Proto.Promises.Promise`1"/>.</returns>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten, or it has not yet completed.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseProgressNoThrowAwaiter`1.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the <see cref="T:Proto.Promises.Promise`1"/> associated with this <see cref="T:Proto.Promises.Async.CompilerServices.PromiseAwaiter`1"/>.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
            <exception cref="T:Proto.Promises.InvalidOperationException">The <see cref="T:Proto.Promises.Promise`1"/> has already been awaited or forgotten.</exception>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder">
            <summary>
            Provides a builder for asynchronous methods that return <see cref="T:Proto.Promises.Promise"/>.
            This type is intended for compiler use only.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.AwaitOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.Start``1(``0@)">
            <summary>Initiates the builder's execution with the associated state machine.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Does nothing.</summary>
            <param name="stateMachine">The heap-allocated state machine object.</param>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.Task">
            <summary>Gets the <see cref="T:Proto.Promises.Promise"/> for this builder.</summary>
            <returns>The <see cref="T:Proto.Promises.Promise"/> representing the builder's asynchronous operation.</returns>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.Create">
            <summary>Initializes a new <see cref="T:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder"/>.</summary>
            <returns>The initialized <see cref="T:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder"/>.</returns>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.SetException(System.Exception)">
            <summary>
            Completes the <see cref="T:Proto.Promises.Promise"/> in the <see cref="T:Proto.Promises.Promise.State">Rejected</see> state with the specified exception.
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> to use to reject the promise.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder.SetResult">
            <summary>
            Completes the <see cref="T:Proto.Promises.Promise"/> in the <see cref="T:Proto.Promises.Promise.State">Resolved</see> state.
            </summary>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1">
            <summary>
            Provides a builder for asynchronous methods that return <see cref="T:Proto.Promises.Promise`1"/>.
            This type is intended for compiler use only.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.AwaitOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.AwaitUnsafeOnCompleted``2(``0@,``1@)">
            <summary>
            Schedules the specified state machine to be pushed forward when the specified awaiter completes.
            </summary>
            <typeparam name="TAwaiter">Specifies the type of the awaiter.</typeparam>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="awaiter">The awaiter.</param>
            <param name="stateMachine">The state machine.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.Start``1(``0@)">
            <summary>Initiates the builder's execution with the associated state machine.</summary>
            <typeparam name="TStateMachine">Specifies the type of the state machine.</typeparam>
            <param name="stateMachine">The state machine instance, passed by reference.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.SetStateMachine(System.Runtime.CompilerServices.IAsyncStateMachine)">
            <summary>Does nothing.</summary>
            <param name="stateMachine">The heap-allocated state machine object.</param>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.Task">
            <summary>Gets the <see cref="T:Proto.Promises.Promise`1"/> for this builder.</summary>
            <returns>The <see cref="T:Proto.Promises.Promise`1"/> representing the builder's asynchronous operation.</returns>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.Create">
            <summary>Initializes a new <see cref="T:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1"/>.</summary>
            <returns>The initialized <see cref="T:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1"/>.</returns>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.SetException(System.Exception)">
            <summary>
            Completes the <see cref="T:Proto.Promises.Promise`1"/> in the <see cref="T:Proto.Promises.Promise.State">Rejected</see> state with the specified exception.
            </summary>
            <param name="exception">The <see cref="T:System.Exception"/> to use to reject the promise.</param>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseMethodBuilder`1.SetResult(`0)">
            <summary>
            Completes the <see cref="T:Proto.Promises.Promise`1"/> in the <see cref="T:Proto.Promises.Promise.State">Resolved</see> state with the specified result.
            </summary>
            <param name="result">The result to use to complete the task.</param>
        </member>
        <member name="T:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter">
            <summary>
            Provides an awaiter for switching to a context.
            </summary>
            <remarks>This type is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter.#ctor(System.Threading.SynchronizationContext,System.Boolean)">
            <summary>
            Internal use.
            </summary>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter.GetAwaiter">
            <summary>Gets the awaiter for this.</summary>
            <remarks>This method is intended for compiler use rather than use directly in code.</remarks>
            <returns>this</returns>
        </member>
        <member name="P:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter.IsCompleted">
            <summary>Gets whether the <see cref="T:Proto.Promises.Promise"/> being awaited is completed.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter.GetResult">
            <summary>Ends the await on the context.</summary>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter.OnCompleted(System.Action)">
            <summary>Schedules the continuation onto the context.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="M:Proto.Promises.Async.CompilerServices.PromiseSwitchToContextAwaiter.UnsafeOnCompleted(System.Action)">
            <summary>Schedules the continuation onto the context.</summary>
            <param name="continuation">The action to invoke when the await operation completes.</param>
            <remarks>This property is intended for compiler use rather than use directly in code.</remarks>
        </member>
        <member name="T:Proto.Promises.SynchronizationOption">
            <summary>
            How the next continuation should be scheduled.
            </summary>
        </member>
        <member name="F:Proto.Promises.SynchronizationOption.Synchronous">
            <summary>
            Schedule the next continuation to execute synchronously.
            </summary>
        </member>
        <member name="F:Proto.Promises.SynchronizationOption.Foreground">
            <summary>
            Schedule the next continuation to execute on the <see cref="P:Proto.Promises.Promise.Config.ForegroundContext"/>.
            </summary>
        </member>
        <member name="F:Proto.Promises.SynchronizationOption.Background">
            <summary>
            Schedule the next continuation to execute on the <see cref="P:Proto.Promises.Promise.Config.BackgroundContext"/>.
            </summary>
        </member>
        <member name="T:Proto.Promises.UnhandledException">
            <summary>
            Exception that is thrown if a promise is rejected and that rejection is never handled.
            </summary>
        </member>
        <member name="T:Proto.Promises.CanceledException">
            <summary>
            Exception that is used to propagate cancelation of an operation.
            </summary>
        </member>
        <member name="T:Proto.Promises.RethrowException">
            <summary>
            Special Exception that is used to rethrow a rejection from a Promise onRejected callback.
            </summary>
        </member>
        <member name="T:Proto.Promises.RejectException">
            <summary>
            Special Exception that is used to reject a Promise from an onResolved or onRejected callback.
            </summary>
        </member>
        <member name="T:Proto.Promises.ReasonContainer">
            <summary>
            Used to get the value of a rejection or cancelation.
            An instance of <see cref="T:Proto.Promises.ReasonContainer"/> is only valid during the invocation of the delegate it is passed into.
            </summary>
        </member>
        <member name="M:Proto.Promises.ReasonContainer.#ctor(Proto.Promises.Internal.IRejectContainer)">
            <summary>
            FOR INTERNAL USE ONLY!
            </summary>
        </member>
        <member name="P:Proto.Promises.ReasonContainer.ValueType">
            <summary>
            Get the type of the value.
            </summary>
        </member>
        <member name="P:Proto.Promises.ReasonContainer.Value">
            <summary>
            Get the value.
            </summary>
        </member>
        <member name="M:Proto.Promises.ReasonContainer.TryGetValueAs``1(``0@)">
            <summary>
            Try to get the value casted to <typeparamref name="T"/>.
            Returns true if successful, false otherwise.
            </summary>
        </member>
        <member name="T:Proto.Promises.Threading.AsyncAutoResetEvent">
            <summary>
            An async-compatible auto-reset event.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates an async-compatible auto-reset event.
            </summary>
            <param name="initialState">Whether the auto-reset event is initially set or unset.</param>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.#ctor">
            <summary>
            Creates an async-compatible auto-reset event that is initially unset.
            </summary>
        </member>
        <member name="P:Proto.Promises.Threading.AsyncAutoResetEvent.IsSet">
            <summary>
            Whether this event is currently set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.WaitAsync">
            <summary>
            Asynchronously wait for this event to be set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.TryWaitAsync(Proto.Promises.CancelationToken)">
            <summary>
            Asynchronously wait for this event to be set, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The result of the returned <see cref="T:Proto.Promises.Promise`1"/> will be <see langword="true"/> if this is set before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is already set, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.Wait">
            <summary>
            Synchronously wait for this event to be set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.TryWait(Proto.Promises.CancelationToken)">
            <summary>
            Synchronously wait for this event to be set, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The returned value will be <see langword="true"/> if this is set before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is already set, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.Set">
            <summary>
            Sets this event, completing a waiter.
            </summary>
            <remarks>
            If there are any pending waiters, this event will be reset, and a single waiter will be completed atomically.
            If this event is already set, this does nothing.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.Reset">
            <summary>
            Resets this event.
            </summary>
            <remarks>
            If this event is already reset, this does nothing.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncAutoResetEvent.GetAwaiter">
            <summary>
            Asynchronous infrastructure support. This method permits instances of <see cref="T:Proto.Promises.Threading.AsyncAutoResetEvent"/> to be awaited.
            </summary>
        </member>
        <member name="T:Proto.Promises.Threading.AsyncCountdownEvent">
            <summary>
            An async-compatible countdown event.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.#ctor(System.Int32)">
            <summary>
            Creates an async-compatible countdown event.
            </summary>
            <param name="initialCount">The number of signals initially required to set the <see cref="T:Proto.Promises.Threading.AsyncCountdownEvent"/>.</param>
        </member>
        <member name="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount">
            <summary>
            Gets the number of remaining signals required to set the event.
            </summary>
        </member>
        <member name="P:Proto.Promises.Threading.AsyncCountdownEvent.InitialCount">
            <summary>
            Gets the numbers of signals initially required to set the event.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.AddCount">
            <summary>
            Increments <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> by one.
            </summary>
            <exception cref="T:Proto.Promises.InvalidOperationException">The current instance is already set, or the <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> is equal to or greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.AddCount(System.Int32)">
            <summary>
            Increments <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> by a specified value.
            </summary>
            <param name="signalCount">The value by which to increase <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/>.</param>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"><paramref name="signalCount"/> is less than or equal to 0.</exception>
            <exception cref="T:Proto.Promises.InvalidOperationException">
            The current instance is already set, or <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> + <paramref name="signalCount"/> is equal to or greater than <see cref="F:System.Int32.MaxValue"/>.
            </exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.TryAddCount">
            <summary>
            Attempts to increment <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> by one.
            </summary>
            <returns><see langword="true"/> if the increment succeeded; otherwise, <see langword="false"/>. If <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> is already 0, this will return <see langword="false"/>.</returns>
            <exception cref="T:Proto.Promises.InvalidOperationException"><see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> is equal to or greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.TryAddCount(System.Int32)">
            <summary>
            Attempts to increment <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> by a specified value.
            </summary>
            <param name="signalCount">The value by which to increase <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/>.</param>
            <returns><see langword="true"/> if the increment succeeded; otherwise, <see langword="false"/>. If <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> is already 0, this will return <see langword="false"/>.</returns>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"><paramref name="signalCount"/> is less than or equal to 0.</exception>
            <exception cref="T:Proto.Promises.InvalidOperationException"><see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> + <paramref name="signalCount"/> is equal to or greater than <see cref="F:System.Int32.MaxValue"/>.</exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.Reset">
            <summary>
            Resets the <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> to the value of <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.InitialCount"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.Reset(System.Int32)">
            <summary>
            Resets the <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.InitialCount"/> and <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> to a specified value.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.Signal">
            <summary>
            Registers a signal with the <see cref="T:Proto.Promises.Threading.AsyncCountdownEvent"/>, decrementing the value of <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/>.
            </summary>
            <returns><see langword="true"/> if the signal caused the count to reach zero and the event was set; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:Proto.Promises.InvalidOperationException">The current instance is already set.</exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.Signal(System.Int32)">
            <summary>
            Registers multiple signals with the <see cref="T:Proto.Promises.Threading.AsyncCountdownEvent"/>, decrementing the value of <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/> by the specified amount.
            </summary>
            <param name="signalCount">The number of signals to register.</param>
            <returns><see langword="true"/> if the signals caused the count to reach zero and the event was set; otherwise, <see langword="false"/>.</returns>
            <exception cref="T:Proto.Promises.ArgumentOutOfRangeException"><paramref name="signalCount"/> is less than 1.</exception>
            <exception cref="T:Proto.Promises.InvalidOperationException">The current instance is already set, or <paramref name="signalCount"/> is greater than <see cref="P:Proto.Promises.Threading.AsyncCountdownEvent.CurrentCount"/>.</exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.WaitAsync">
            <summary>
            Asynchronously wait for this event to be set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.TryWaitAsync(Proto.Promises.CancelationToken)">
            <summary>
            Asynchronously wait for this event to be set, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The result of the returned <see cref="T:Proto.Promises.Promise`1"/> will be <see langword="true"/> if this is set before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is already set, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.Wait">
            <summary>
            Synchronously wait for this event to be set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.TryWait(Proto.Promises.CancelationToken)">
            <summary>
            Synchronously wait for this event to be set, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The returned value will be <see langword="true"/> if this is set before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is already set, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncCountdownEvent.GetAwaiter">
            <summary>
            Asynchronous infrastructure support. This method permits instances of <see cref="T:Proto.Promises.Threading.AsyncManualResetEvent"/> to be awaited.
            </summary>
        </member>
        <member name="T:Proto.Promises.Threading.AsyncManualResetEvent">
            <summary>
            An async-compatible manual-reset event.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.#ctor(System.Boolean)">
            <summary>
            Creates an async-compatible manual-reset event.
            </summary>
            <param name="initialState">Whether the manual-reset event is initially set or unset.</param>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.#ctor">
            <summary>
            Creates an async-compatible manual-reset event that is initially unset.
            </summary>
        </member>
        <member name="P:Proto.Promises.Threading.AsyncManualResetEvent.IsSet">
            <summary>
            Whether this event is currently set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.WaitAsync">
            <summary>
            Asynchronously wait for this event to be set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.TryWaitAsync(Proto.Promises.CancelationToken)">
            <summary>
            Asynchronously wait for this event to be set, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The result of the returned <see cref="T:Proto.Promises.Promise`1"/> will be <see langword="true"/> if this is set before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is already set, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.Wait">
            <summary>
            Synchronously wait for this event to be set.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.TryWait(Proto.Promises.CancelationToken)">
            <summary>
            Synchronously wait for this event to be set, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The returned value will be <see langword="true"/> if this is set before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is already set, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.Set">
            <summary>
            Sets this event, completing every wait.
            </summary>
            <remarks>
            If this event is already set, this does nothing.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.Reset">
            <summary>
            Resets this event.
            </summary>
            <remarks>
            If this event is already reset, this does nothing.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncManualResetEvent.GetAwaiter">
            <summary>
            Asynchronous infrastructure support. This method permits instances of <see cref="T:Proto.Promises.Threading.AsyncManualResetEvent"/> to be awaited.
            </summary>
        </member>
        <member name="T:Proto.Promises.Threading.AsyncSemaphore">
            <summary>
            An async-compatible manual-reset event.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.#ctor(System.Int32)">
            <summary>
            Creates an async-compatible Semaphore, specifying
            the initial number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="initialCount"/> is less than 0.</exception>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates an async-compatible Semaphore, specifying
            the initial and maximum number of requests that can be granted concurrently.
            </summary>
            <param name="initialCount">The initial number of requests for the semaphore that can be granted
            concurrently.</param>
            <param name="maxCount">The maximum number of requests for the semaphore that can be granted
            concurrently.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="initialCount"/> is less than 0. -or-
            <paramref name="initialCount"/> is greater than <paramref name="maxCount"/>. -or-
            <paramref name="maxCount"/> is equal to or less than 0.</exception>
        </member>
        <member name="P:Proto.Promises.Threading.AsyncSemaphore.CurrentCount">
            <summary>
            Get the number of times remaining that this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/> can be entered concurrently.
            </summary>
            <remarks>
            The initial value of the <see cref="P:Proto.Promises.Threading.AsyncSemaphore.CurrentCount"/> property is set by the call to the <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/> class constructor.
            It is decremented by each call to the <see cref="M:Proto.Promises.Threading.AsyncSemaphore.Wait"/> or <see cref="M:Proto.Promises.Threading.AsyncSemaphore.WaitAsync"/> methods, and incremented by each call to the <see cref="M:Proto.Promises.Threading.AsyncSemaphore.Release"/> method.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.WaitAsync">
            <summary>
            Asynchronously wait to enter this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.TryWaitAsync(Proto.Promises.CancelationToken)">
            <summary>
            Asynchronously wait to enter this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/>, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The result of the returned <see cref="T:Proto.Promises.Promise`1"/> will be <see langword="true"/> if this is entered before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is available to be entered, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.Wait">
            <summary>
            Synchronously wait to enter this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.TryWait(Proto.Promises.CancelationToken)">
            <summary>
            Synchronously wait to enter this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/>, or for the <paramref name="cancelationToken"/> to be canceled.
            </summary>
            <param name="cancelationToken">The <see cref="T:Proto.Promises.CancelationToken"/> used to cancel the wait.</param>
            <remarks>
            The returned value will be <see langword="true"/> if this is entered before the <paramref name="cancelationToken"/> was canceled, otherwise it will be <see langword="false"/>.
            If this is available to be entered, the result will be <see langword="true"/>, even if the <paramref name="cancelationToken"/> is already canceled.
            </remarks>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.Release">
            <summary>
            Exit this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/> once.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.AsyncSemaphore.Release(System.Int32)">
            <summary>
            Exit this <see cref="T:Proto.Promises.Threading.AsyncSemaphore"/> a specified number of times.
            </summary>
        </member>
        <member name="T:Proto.Promises.Threading.PromiseSynchronizationContext">
            <summary>
            A <see cref="T:System.Threading.SynchronizationContext"/> used to schedule callbacks to the thread that it was created on.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.PromiseSynchronizationContext.#ctor">
            <summary>
            Create a new <see cref="T:Proto.Promises.Threading.PromiseSynchronizationContext"/> affiliated with the current thread.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.PromiseSynchronizationContext.#ctor(System.Threading.Thread)">
            <summary>
            Create a new <see cref="T:Proto.Promises.Threading.PromiseSynchronizationContext"/> affiliated with the <paramref name="runThread"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.PromiseSynchronizationContext.CreateCopy">
            <summary>
            Create copy.
            </summary>
            <returns>this</returns>
        </member>
        <member name="M:Proto.Promises.Threading.PromiseSynchronizationContext.Post(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Schedule the delegate to execute on this context with the given state asynchronously, without waiting for it to complete.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.PromiseSynchronizationContext.Send(System.Threading.SendOrPostCallback,System.Object)">
            <summary>
            Schedule the delegate to execute on this context with the given state, and wait for it to complete.
            </summary>
        </member>
        <member name="M:Proto.Promises.Threading.PromiseSynchronizationContext.Execute">
            <summary>
            Execute all callbacks that have been scheduled to run on this context.
            </summary>
            <exception cref="T:System.InvalidOperationException">If this is called on a different thread than this was created on, or if this is called recursively.</exception>
            <exception cref="T:Proto.Promises.AggregateException">If one or more callbacks throw an exception, they will be wrapped and rethrown as <see cref="T:Proto.Promises.AggregateException"/>.</exception>
        </member>
        <member name="T:Proto.Promises.AsyncLazy`1">
            <summary>
            Provides support for asynchronous lazy initialization.
            </summary>
            <typeparam name="T">The type of object that is being lazily initialized.</typeparam>
        </member>
        <member name="M:Proto.Promises.AsyncLazy`1.#ctor(System.Func{Proto.Promises.Promise{`0}})">
            <summary>
            Initializes a new instance of the <see cref="T:Proto.Promises.AsyncLazy`1"/> class that uses the specified initialization function.
            </summary>
            <param name="asyncValueFactory">The delegate that is invoked to produce the lazily initialized value when it is needed.</param>
        </member>
        <member name="P:Proto.Promises.AsyncLazy`1.IsStarted">
            <summary>
            Whether the asynchronous factory method has started. This is initially <c>false</c> and becomes <c>true</c> when this instance is awaited or after <see cref="P:Proto.Promises.AsyncLazy`1.Promise"/> is accessed.
            </summary>
            <remarks>This reverts to <c>false</c> if the factory does not complete successfully.</remarks>
        </member>
        <member name="P:Proto.Promises.AsyncLazy`1.Promise">
            <summary>
            Starts the asynchronous factory method, if it has not already started, and returns the resulting <see cref="T:Proto.Promises.Promise`1"/>.
            </summary>
        </member>
        <member name="M:Proto.Promises.AsyncLazy`1.GetAwaiter">
            <summary>
            Asynchronous infrastructure support. This method permits instances of <see cref="T:Proto.Promises.AsyncLazy`1"/> to be awaited.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Indicates that the use of <see cref="T:System.ValueTuple"/> on a member is meant to be treated as a tuple with element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute"/> class.
            </summary>
            <param name="transformNames">
            Specifies, in a prefix traversal of a type's
            construction, which <see cref="T:System.ValueType"/> occurrences are meant to 
            carry element names.
            </param>
            <remarks>
            This constructor is meant to be used on types that are built on an underlying
            occurrence of <see cref="T:System.ValueType"/> that is meant to carry element names.
            For instance, if <c>C</c> is a generic type with two type parameters, then a
            use of the constructed type <c>C{<see cref="T:System.ValueTuple`2"/>, <see cref="T:System.ValueTuple`3"/></c>
            might be intended to treat the first type argument as a tuple with element names
            and the second as a tuple without element names. In which case, the appropriate attribute
            specification should use <c>transformNames</c> value of <c>{ "name1", "name2", null }</c>.
            </remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute"/> class.
            </summary>
            <remarks>
            When <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute"/> is created with this constructor,
            it can be omitted instead.
            </remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
            Specifies, in a prefix traversal of a type's
            construction, which <see cref="T:System.ValueTuple"/> occurrences are meant to
            carry element names.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>
            This interface is required for types that want to be indexed into by dynamic patterns.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's second component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.System#Collections#IStructuralEquatable#Equals(System.Object,System.Collections.IEqualityComparer)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object based on a specified comparison method.
             </summary>
             <param name="other">The object to compare with this instance.</param>
             <param name="comparer">An object that defines the method to use to evaluate whether the two objects are equal.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             This member is an explicit interface member implementation. It can be used only when the
              <see cref="T:System.ValueTuple`2"/> instance is cast to an <see cref="T:System.Collections.IStructuralEquatable"/> interface.
            
             The <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation is called only if <c>other</c> is not <see langword="null"/>,
              and if it can be successfully cast (in C#) or converted (in Visual Basic) to a <see cref="T:System.ValueTuple`2"/>
              whose components are of the same types as those of the current instance. The IStructuralEquatable.Equals(Object, IEqualityComparer) method
              first passes the <see cref="F:System.ValueTuple`2.Item1"/> values of the <see cref="T:System.ValueTuple`2"/> objects to be compared to the
              <see cref="M:System.Collections.IEqualityComparer.Equals(System.Object,System.Object)"/> implementation. If this method call returns <see langword="true"/>, the method is
              called again and passed the <see cref="F:System.ValueTuple`2.Item2"/> values of the two <see cref="T:System.ValueTuple`2"/> instances.
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater 
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
    </members>
</doc>
